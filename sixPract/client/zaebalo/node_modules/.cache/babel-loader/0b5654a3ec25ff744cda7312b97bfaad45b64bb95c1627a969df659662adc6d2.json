{"ast":null,"code":"import { useState as $8D3nr$useState, useMemo as $8D3nr$useMemo, useEffect as $8D3nr$useEffect, useCallback as $8D3nr$useCallback } from \"react\";\nimport { useLayoutEffect as $8D3nr$useLayoutEffect } from \"@react-aria/utils\";\nimport $8D3nr$swchelperssrc_define_propertymjs from \"@swc/helpers/src/_define_property.mjs\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n    * Copyright 2020 Adobe. All rights reserved.\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License. You may obtain a copy\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software distributed under\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n    * OF ANY KIND, either express or implied. See the License for the specific language\n    * governing permissions and limitations under the License.\n    */\nclass $c74cda7d31af1253$export$c84671f46d6a1ca {\n  /**\n  * Returns whether the layout should invalidate in response to\n  * visible rectangle changes. By default, it only invalidates\n  * when the collection view's size changes. Return true always\n  * to make the layout invalidate while scrolling (e.g. sticky headers).\n  */\n  shouldInvalidate(newRect, oldRect) {\n    // By default, invalidate when the size changes\n    return newRect.width !== oldRect.width || newRect.height !== oldRect.height;\n  }\n  /**\n  * This method allows the layout to perform any pre-computation\n  * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n  * Called by the collection view before {@link getVisibleLayoutInfos}\n  * or {@link getLayoutInfo} are called.\n  */\n  validate(invalidationContext) {}\n  /**\n  * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n  * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n  * @param point The point at which the drag occurred.\n  */ // getDragTarget(point: Point): DragTarget | null {\n  //   let target = this.virtualizer.keyAtPoint(point);\n  //   if (!target) {\n  //     return null;\n  //   }\n  //   return {\n  //     type: 'item',\n  //     key: target\n  //   };\n  // }\n  /**\n  * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n  * to reject the drop. The dropped items will be inserted before the resulting target.\n  * @param point The point at which the drop occurred.\n  */ // getDropTarget(point: Point): DropTarget | null {\n  //   return null;\n  // }\n  /**\n  * Returns the starting attributes for an animated insertion.\n  * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n  * The default implementation just returns its input.\n  *\n  * @param layoutInfo The proposed LayoutInfo for this view.\n  */\n  getInitialLayoutInfo(layoutInfo) {\n    return layoutInfo;\n  }\n  /**\n  * Returns the ending attributes for an animated removal.\n  * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n  * to the one returned by this method. The default implementation returns its input.\n  *\n  * @param layoutInfo The original LayoutInfo for this view.\n  */\n  getFinalLayoutInfo(layoutInfo) {\n    return layoutInfo;\n  }\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nclass $d7fd61009c21d0bb$export$7e0eeb9da702a085 {\n  /**\n  * Returns a copy of the LayoutInfo.\n  */\n  copy() {\n    let res = new $d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());\n    res.estimatedSize = this.estimatedSize;\n    res.opacity = this.opacity;\n    res.transform = this.transform;\n    res.parentKey = this.parentKey;\n    res.isSticky = this.isSticky;\n    res.zIndex = this.zIndex;\n    res.allowOverflow = this.allowOverflow;\n    return res;\n  }\n  /**\n  * @param type A string representing the view type. Should be `'item'` for item views.\n                          Other types are used by supplementary views.\n  * @param key The unique key for this view.\n  * @param rect The rectangle describing the size and position of this view.\n  */\n  constructor(type, key, rect) {\n    this.type = type;\n    this.key = key;\n    this.parentKey = null;\n    this.rect = rect;\n    this.estimatedSize = false;\n    this.isSticky = false;\n    this.opacity = 1;\n    this.transform = null;\n    this.zIndex = 0;\n    this.allowOverflow = false;\n  }\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nclass $3041db3296945e6e$export$baf26146a414f24a {\n  /**\n  * Returns a copy of this point.\n  */\n  copy() {\n    return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n  }\n  /**\n  * Checks if two points are equal.\n  */\n  equals(point) {\n    return this.x === point.x && this.y === point.y;\n  }\n  /**\n  * Returns true if this point is the origin.\n  */\n  isOrigin() {\n    return this.x === 0 && this.y === 0;\n  }\n  constructor() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.x = x;\n    this.y = y;\n  }\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nclass $60423f92c7f9ad87$export$c79fc6492f3af13d {\n  /**\n  * The maximum x-coordinate in the rectangle.\n  */\n  get maxX() {\n    return this.x + this.width;\n  }\n  /**\n  * The maximum y-coordinate in the rectangle.\n  */\n  get maxY() {\n    return this.y + this.height;\n  }\n  /**\n  * The area of the rectangle.\n  */\n  get area() {\n    return this.width * this.height;\n  }\n  /**\n  * The top left corner of the rectangle.\n  */\n  get topLeft() {\n    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.y);\n  }\n  /**\n  * The top right corner of the rectangle.\n  */\n  get topRight() {\n    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.y);\n  }\n  /**\n  * The bottom left corner of the rectangle.\n  */\n  get bottomLeft() {\n    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.maxY);\n  }\n  /**\n  * The bottom right corner of the rectangle.\n  */\n  get bottomRight() {\n    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.maxY);\n  }\n  /**\n  * Returns whether this rectangle intersects another rectangle.\n  * @param rect - The rectangle to check.\n  */\n  intersects(rect) {\n    return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;\n  }\n  /**\n  * Returns whether this rectangle fully contains another rectangle.\n  * @param rect - The rectangle to check.\n  */\n  containsRect(rect) {\n    return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;\n  }\n  /**\n  * Returns whether the rectangle contains the given point.\n  * @param point - The point to check.\n  */\n  containsPoint(point) {\n    return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;\n  }\n  /**\n  * Returns the first corner of this rectangle (from top to bottom, left to right)\n  * that is contained in the given rectangle, or null of the rectangles do not intersect.\n  * @param rect - The rectangle to check.\n  */\n  getCornerInRect(rect) {\n    for (let key of [\"topLeft\", \"topRight\", \"bottomLeft\", \"bottomRight\"]) {\n      if (rect.containsPoint(this[key])) return key;\n    }\n    return null;\n  }\n  equals(rect) {\n    return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n  }\n  pointEquals(point) {\n    return this.x === point.x && this.y === point.y;\n  }\n  sizeEquals(size) {\n    return this.width === size.width && this.height === size.height;\n  }\n  /**\n  * Returns the union of this Rect and another.\n  */\n  union(other) {\n    let x = Math.min(this.x, other.x);\n    let y = Math.min(this.y, other.y);\n    let width = Math.max(this.maxX, other.maxX) - x;\n    let height = Math.max(this.maxY, other.maxY) - y;\n    return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, width, height);\n  }\n  /**\n  * Returns the intersection of this Rect with another.\n  * If the rectangles do not intersect, an all zero Rect is returned.\n  */\n  intersection(other) {\n    if (!this.intersects(other)) return new $60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, 0, 0);\n    let x = Math.max(this.x, other.x);\n    let y = Math.max(this.y, other.y);\n    return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, Math.min(this.maxX, other.maxX) - x, Math.min(this.maxY, other.maxY) - y);\n  }\n  /**\n  * Returns a copy of this rectangle.\n  */\n  copy() {\n    return new $60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);\n  }\n  constructor() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nclass $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec {\n  /**\n  * Returns a copy of this size.\n  */\n  copy() {\n    return new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);\n  }\n  /**\n  * Returns whether this size is equal to another one.\n  */\n  equals(other) {\n    return this.width === other.width && this.height === other.height;\n  }\n  /**\n  * The total area of the Size.\n  */\n  get area() {\n    return this.width * this.height;\n  }\n  constructor() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.width = width;\n    this.height = height;\n  }\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nlet $ad1d98aa8f0c31b4$var$KEY = 0;\nclass $ad1d98aa8f0c31b4$export$1a5223887c560441 {\n  /**\n  * Prepares the view for reuse. Called just before the view is removed from the DOM.\n  */\n  prepareForReuse() {\n    this.content = null;\n    this.rendered = null;\n    this.layoutInfo = null;\n  }\n  constructor(virtualizer) {\n    this.virtualizer = virtualizer;\n    this.key = ++$ad1d98aa8f0c31b4$var$KEY;\n  }\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n    * Copyright 2020 Adobe. All rights reserved.\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License. You may obtain a copy\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software distributed under\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n    * OF ANY KIND, either express or implied. See the License for the specific language\n    * governing permissions and limitations under the License.\n    */\n// use high res timer if available\nlet $3eb131dcf37ad5f8$var$perf = typeof window !== \"undefined\" ? window.performance : null;\n// @ts-ignore\nlet $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);\nlet $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function () {\n  return Date.now ? Date.now() : new Date().getTime();\n};\nlet $3eb131dcf37ad5f8$var$fixTs;\nfunction $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn) {\n  let canceled = false;\n  let raf_id;\n  let promise = new Promise(resolve => {\n    let start = $3eb131dcf37ad5f8$var$getTime();\n    let diffX = end.x - begin.x;\n    let diffY = end.y - begin.y;\n    raf_id = requestAnimationFrame(function run(t) {\n      // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n      // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n      if ($3eb131dcf37ad5f8$var$fixTs == null) $3eb131dcf37ad5f8$var$fixTs = t > 1e12 !== $3eb131dcf37ad5f8$var$getTime() > 1e12;\n      if ($3eb131dcf37ad5f8$var$fixTs) t = $3eb131dcf37ad5f8$var$getTime();\n      // check if we're done\n      let delta = t - start;\n      if (delta > duration) {\n        fn(end);\n        resolve();\n      } else {\n        // call frame callback after computing eased time and get the next frame\n        let proceed = fn(new (0, $3041db3296945e6e$export$baf26146a414f24a)(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));\n        if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run);\n      }\n    });\n  });\n  promise.cancel = function () {\n    canceled = true;\n    cancelAnimationFrame(raf_id);\n  };\n  return promise;\n}\nfunction $3eb131dcf37ad5f8$export$77860c106b4a6a2e(t) {\n  return t;\n}\nfunction $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t) {\n  return Math.sin(t * Math.PI / 2);\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nfunction $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b) {\n  let res = new Set();\n  for (let key of a.keys()) if (!b.has(key)) res.add(key);\n  return res;\n}\nfunction $fc36f9a046a9ce79$export$acaf96a27438246b(a, b) {\n  let toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b);\n  let toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b, a);\n  let toUpdate = new Set();\n  for (let key of a.keys()) if (b.has(key)) toUpdate.add(key);\n  return {\n    toRemove: toRemove,\n    toAdd: toAdd,\n    toUpdate: toUpdate\n  };\n}\nfunction* $fc36f9a046a9ce79$export$cfc14088dfefce5f() {\n  for (var _len = arguments.length, iterators = new Array(_len), _key = 0; _key < _len; _key++) {\n    iterators[_key] = arguments[_key];\n  }\n  for (let iterator of iterators) yield* iterator;\n}\nfunction $fc36f9a046a9ce79$export$6897c284b6f9f4dc(object) {\n  let res = {};\n  for (let key in object) res[object[key]] = key;\n  return res;\n}\nfunction $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a, b) {\n  if (a === b) return true;\n  if (a.size !== b.size) return false;\n  for (let key of a) {\n    if (!b.has(key)) return false;\n  }\n  return true;\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $364191b3decf3697$var$RollingAverage {\n  addSample(sample) {\n    this.count++;\n    this.value += (sample - this.value) / this.count;\n  }\n  constructor() {\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"count\", 0);\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"value\", 0);\n  }\n}\nclass $364191b3decf3697$export$4455ee6afb38dcbb {\n  setVisibleRect(rect) {\n    let time = performance.now() - this.startTime;\n    if (time < 500) {\n      this.averageTime.addSample(time);\n      if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;\n      if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;\n    }\n    this.startTime = performance.now();\n    this.visibleRect = rect;\n  }\n  collectMetrics() {\n    let time = performance.now() - this.startTime;\n    if (time < 500) this.averagePerf.addSample(time);\n    if (this.visibleRect.height > 0) {\n      let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));\n      this.overscanY.addSample(o);\n    }\n    if (this.visibleRect.width > 0) {\n      let o1 = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));\n      this.overscanX.addSample(o1);\n    }\n  }\n  getOverscannedRect() {\n    let overscanned = this.visibleRect.copy();\n    let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n    if (this.velocity.y > 0) {\n      overscanned.y -= overscanY * 0.2;\n      overscanned.height += overscanY + overscanY * 0.2;\n    } else {\n      overscanned.y -= overscanY;\n      overscanned.height += overscanY + overscanY * 0.2;\n    }\n    let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n    if (this.velocity.x > 0) {\n      overscanned.x -= overscanX * 0.2;\n      overscanned.width += overscanX + overscanX * 0.2;\n    } else {\n      overscanned.x -= overscanX;\n      overscanned.width += overscanX + overscanX * 0.2;\n    }\n    return overscanned;\n  }\n  constructor() {\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"startTime\", 0);\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"averagePerf\", new $364191b3decf3697$var$RollingAverage());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"averageTime\", new $364191b3decf3697$var$RollingAverage());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"velocity\", new (0, $3041db3296945e6e$export$baf26146a414f24a)(5, 5));\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"overscanX\", new $364191b3decf3697$var$RollingAverage());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"overscanY\", new $364191b3decf3697$var$RollingAverage());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"visibleRect\", new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)());\n  }\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nclass $8e135e531d8dcb66$export$febc5573c75cefb0 {\n  constructor() {\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"level\", 0);\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"actions\", []);\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"animated\", true);\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"initialMap\", new Map());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"finalMap\", new Map());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"initialLayoutInfo\", new Map());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"finalLayoutInfo\", new Map());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"removed\", new Map());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"toRemove\", new Map());\n  }\n}\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n  _setContentSize(size) {\n    this._contentSize = size;\n    this.delegate.setContentSize(size);\n  }\n  _setContentOffset(offset) {\n    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n    this.delegate.setVisibleRect(rect);\n  }\n  /**\n  * Get the size of the scrollable content.\n  */\n  get contentSize() {\n    return this._contentSize;\n  }\n  /**\n  * Get the collection view's currently visible rectangle.\n  */\n  get visibleRect() {\n    return this._visibleRect;\n  }\n  /**\n  * Set the collection view's currently visible rectangle.\n  */\n  set visibleRect(rect) {\n    this._setVisibleRect(rect);\n  }\n  _setVisibleRect(rect) {\n    let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let current = this._visibleRect;\n    // Ignore if the rects are equal\n    if (rect.equals(current)) return;\n    if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n    this._resetAnimatedContentOffset();\n    this._visibleRect = rect;\n    if (shouldInvalidate) this.relayout({\n      offsetChanged: !rect.pointEquals(current),\n      sizeChanged: !rect.sizeEquals(current)\n    });else this.updateSubviews(forceUpdate);\n  }\n  get collection() {\n    return this._collection;\n  }\n  set collection(data) {\n    this._setData(data);\n  }\n  _setData(data) {\n    if (data === this._collection) return;\n    if (this._collection) this._runTransaction(() => {\n      this._collection = data;\n    }, this.transitionDuration > 0);else {\n      this._collection = data;\n      this.reloadData();\n    }\n  }\n  /**\n  * Reloads the data from the data source and relayouts the collection view.\n  * Does not animate any changes. Equivalent to re-assigning the same data source\n  * to the collection view.\n  */\n  reloadData() {\n    this.relayout({\n      contentChanged: true\n    });\n  }\n  /**\n  * Returns the item with the given key.\n  */\n  getItem(key) {\n    return this._collection ? this._collection.getItem(key) : null;\n  }\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  get persistedKeys() {\n    return this._persistedKeys;\n  }\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  set persistedKeys(persistedKeys) {\n    if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {\n      this._persistedKeys = persistedKeys;\n      this.updateSubviews();\n    }\n  }\n  /** Returns whether the given key, or an ancestor, is persisted. */\n  isPersistedKey(key) {\n    // Quick check if the key is directly in the set of persisted keys.\n    if (this._persistedKeys.has(key)) return true;\n    // If not, check if the key is an ancestor of any of the persisted keys.\n    for (let k of this._persistedKeys) while (k != null) {\n      let layoutInfo = this.layout.getLayoutInfo(k);\n      if (!layoutInfo) break;\n      k = layoutInfo.parentKey;\n      if (k === key) return true;\n    }\n    return false;\n  }\n  /**\n  * Get the collection view's layout.\n  */\n  get layout() {\n    return this._layout;\n  }\n  /**\n  * Set the collection view's layout.\n  */\n  set layout(layout) {\n    this.setLayout(layout);\n  }\n  /**\n  * Sets the collection view's layout, optionally with an animated transition\n  * from the current layout to the new layout.\n  * @param layout The layout to switch to.\n  * @param animated Whether to animate the layout change.\n  */\n  setLayout(layout) {\n    let animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (layout === this._layout) return;\n    let applyLayout = () => {\n      if (this._layout)\n        // @ts-ignore\n        this._layout.virtualizer = null;\n      layout.virtualizer = this;\n      this._layout = layout;\n    };\n    if (animated)\n      // Animated layout transitions are really simple, thanks to our transaction support.\n      // We just set the layout inside a transaction action, which runs after the initial\n      // layout infos for the animation are retrieved from the previous layout. Then, the\n      // final layout infos are retrieved from the new layout, and animations occur.\n      this._runTransaction(applyLayout);else {\n      applyLayout();\n      this.relayout();\n    }\n  }\n  _getReuseType(layoutInfo, content) {\n    if (layoutInfo.type === \"item\" && content) {\n      let type = this.delegate.getType ? this.delegate.getType(content) : \"item\";\n      let reuseType = type === \"item\" ? \"item\" : layoutInfo.type + \"_\" + type;\n      return {\n        type: type,\n        reuseType: reuseType\n      };\n    }\n    return {\n      type: layoutInfo.type,\n      reuseType: layoutInfo.type\n    };\n  }\n  getReusableView(layoutInfo) {\n    let content = this.getItem(layoutInfo.key);\n    let {\n      reuseType: reuseType\n    } = this._getReuseType(layoutInfo, content);\n    if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n    let reusable = this._reusableViews[reuseType];\n    let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);\n    view.viewType = reuseType;\n    if (!this._animatedContentOffset.isOrigin()) {\n      layoutInfo = layoutInfo.copy();\n      layoutInfo.rect.x += this._animatedContentOffset.x;\n      layoutInfo.rect.y += this._animatedContentOffset.y;\n    }\n    view.layoutInfo = layoutInfo;\n    this._renderView(view);\n    return view;\n  }\n  _renderView(reusableView) {\n    let {\n      type: type,\n      key: key\n    } = reusableView.layoutInfo;\n    reusableView.content = this.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n  _renderContent(type, content) {\n    let cached = this._renderedContent.get(content);\n    if (cached != null) return cached;\n    let rendered = this.delegate.renderView(type, content);\n    if (content) this._renderedContent.set(content, rendered);\n    return rendered;\n  }\n  /**\n  * Returns an array of all currently visible views, including both\n  * item views and supplementary views.\n  */\n  get visibleViews() {\n    return Array.from(this._visibleViews.values());\n  }\n  /**\n  * Gets the visible view for the given type and key. Returns null if\n  * the view is not currently visible.\n  *\n  * @param key The key of the view to retrieve.\n  */\n  getView(key) {\n    return this._visibleViews.get(key) || null;\n  }\n  /**\n  * Returns an array of visible views matching the given type.\n  * @param type The view type to find.\n  */\n  getViewsOfType(type) {\n    return this.visibleViews.filter(v => v.layoutInfo && v.layoutInfo.type === type);\n  }\n  /**\n  * Returns the key for the given view. Returns null\n  * if the view is not currently visible.\n  */\n  keyForView(view) {\n    if (view && view.layoutInfo) return view.layoutInfo.key;\n    return null;\n  }\n  /**\n  * Returns the key for the item view currently at the given point.\n  */\n  keyAtPoint(point) {\n    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    // Layout may return multiple layout infos in the case of\n    // persisted keys, so find the first one that actually intersects.\n    for (let layoutInfo of layoutInfos) {\n      if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n    }\n    return null;\n  }\n  /**\n  * Cleanup for when the Virtualizer will be unmounted.\n  */\n  willUnmount() {\n    cancelAnimationFrame(this._relayoutRaf);\n  }\n  /**\n  * Triggers a layout invalidation, and updates the visible subviews.\n  */\n  relayout() {\n    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Ignore relayouts while animating the scroll position\n    if (this._scrollAnimation || typeof requestAnimationFrame === \"undefined\") return;\n    // If we already scheduled a relayout, extend the invalidation\n    // context so we coalesce multiple relayouts in the same frame.\n    if (this._invalidationContext) {\n      Object.assign(this._invalidationContext, context);\n      return;\n    }\n    this._invalidationContext = context;\n    this._relayoutRaf = requestAnimationFrame(() => {\n      this._relayoutRaf = null;\n      this.relayoutNow();\n    });\n  }\n  /**\n  * Performs a relayout immediately. Prefer {@link relayout} over this method\n  * where possible, since it coalesces multiple layout passes in the same tick.\n  */\n  relayoutNow() {\n    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._invalidationContext || {};\n    // Cancel the scheduled relayout, since we're doing it now.\n    if (this._relayoutRaf) {\n      cancelAnimationFrame(this._relayoutRaf);\n      this._relayoutRaf = null;\n      // Update the provided context with the current invalidationContext since we are cancelling\n      // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n      context = {\n        ...this._invalidationContext,\n        ...context\n      };\n    }\n    // Reset the invalidation context\n    this._invalidationContext = null;\n    // Do nothing if we don't have a layout or content, or we are\n    // in the middle of an animated scroll transition.\n    if (!this.layout || !this._collection || this._scrollAnimation) return;\n    let scrollAnchor = this._getScrollAnchor();\n    // Trigger the beforeLayout hook, if provided\n    if (typeof context.beforeLayout === \"function\") context.beforeLayout();\n    // Validate the layout\n    this.layout.validate(context);\n    this._setContentSize(this.layout.getContentSize());\n    // Trigger the afterLayout hook, if provided\n    if (typeof context.afterLayout === \"function\") context.afterLayout();\n    // Adjust scroll position based on scroll anchor, and constrain.\n    // If the content changed, scroll to the top.\n    let visibleRect = this.getVisibleRect();\n    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n    let hasLayoutUpdates = false;\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n      // Save the difference between the current and new content offsets, and apply it to the\n      // individual content items instead. At the end of the animation, we'll reset and set the\n      // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n      // the scroll animation and the content animation.\n      if (context.animated || !this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n        hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n      } else this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));\n    } else hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n    // Apply layout infos, unless this is coming from an animated transaction\n    if (!(context.transaction && context.animated)) this._applyLayoutInfos();\n    // Wait for animations, and apply the afterAnimation hook, if provided\n    if (context.animated && hasLayoutUpdates) {\n      this._enableTransitions();\n      let done = () => {\n        this._disableTransitions();\n        // Reset scroll position after animations (see above comment).\n        if (!this._animatedContentOffset.isOrigin()) {\n          // Get the content offset to scroll to, taking _animatedContentOffset into account.\n          let {\n            x: x,\n            y: y\n          } = this.getVisibleRect();\n          this._resetAnimatedContentOffset();\n          this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));\n        }\n        if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n      };\n      // Sometimes the animation takes slightly longer than expected.\n      setTimeout(done, this.transitionDuration + 100);\n      return;\n    } else if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n  }\n  /**\n  * Corrects DOM order of visible views to match item order of collection.\n  */\n  _correctItemOrder() {\n    // Defer until after scrolling and animated transactions are complete\n    if (this._isScrolling || this._transaction) return;\n    for (let key of this._visibleLayoutInfos.keys()) {\n      let view = this._visibleViews.get(key);\n      this._children.delete(view);\n      this._children.add(view);\n    }\n  }\n  _enableTransitions() {\n    this.delegate.beginAnimations();\n  }\n  _disableTransitions() {\n    this.delegate.endAnimations();\n  }\n  _getScrollAnchor() {\n    if (!this.anchorScrollPosition) return null;\n    let visibleRect = this.getVisibleRect();\n    // Ask the delegate to provide a scroll anchor, if possible\n    if (this.delegate.getScrollAnchor) {\n      let key = this.delegate.getScrollAnchor(visibleRect);\n      if (key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n        if (corner) {\n          let key1 = layoutInfo.key;\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          return {\n            key: key1,\n            layoutInfo: layoutInfo,\n            corner: corner,\n            offset: offset\n          };\n        }\n      }\n    }\n    // No need to anchor the scroll position if it is at the top\n    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null;\n    // Find a view with a visible corner that has the smallest distance to the top of the collection view\n    let cornerAnchor = null;\n    for (let [key2, view] of this._visibleViews) {\n      let layoutInfo1 = view.layoutInfo;\n      if (layoutInfo1 && layoutInfo1.rect.area > 0) {\n        let corner1 = layoutInfo1.rect.getCornerInRect(visibleRect);\n        if (corner1) {\n          let offset1 = layoutInfo1.rect[corner1].y - visibleRect.y;\n          if (!cornerAnchor || offset1 < cornerAnchor.offset) cornerAnchor = {\n            key: key2,\n            layoutInfo: layoutInfo1,\n            corner: corner1,\n            offset: offset1\n          };\n        }\n      }\n    }\n    return cornerAnchor;\n  }\n  _restoreScrollAnchor(scrollAnchor, context) {\n    let contentOffset = this.getVisibleRect();\n    if (scrollAnchor) {\n      var _context_transaction;\n      let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n      if (finalAnchor) {\n        let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n        contentOffset.y += adjustment;\n      }\n    }\n    return contentOffset;\n  }\n  getVisibleRect() {\n    let v = this.visibleRect;\n    let x = v.x - this._animatedContentOffset.x;\n    let y = v.y - this._animatedContentOffset.y;\n    return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, v.width, v.height);\n  }\n  getVisibleLayoutInfos() {\n    let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n    return this._visibleLayoutInfos;\n  }\n  _getLayoutInfoMap(rect) {\n    let copy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map();\n    for (let layoutInfo of layoutInfos) {\n      if (copy) layoutInfo = layoutInfo.copy();\n      map.set(layoutInfo.key, layoutInfo);\n    }\n    return map;\n  }\n  updateSubviews() {\n    let forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!this._collection) return;\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n    let currentlyVisible = this._visibleViews;\n    let toAdd, toRemove, toUpdate;\n    // If this is a force update, remove and re-add all views.\n    // Otherwise, find and update the diff.\n    if (forceUpdate) {\n      toAdd = visibleLayoutInfos;\n      toRemove = currentlyVisible;\n      toUpdate = new Set();\n    } else {\n      ({\n        toAdd: toAdd,\n        toRemove: toRemove,\n        toUpdate: toUpdate\n      } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));\n      for (let key of toUpdate) {\n        let view = currentlyVisible.get(key);\n        if (!view || !view.layoutInfo) continue;\n        let item = this.getItem(visibleLayoutInfos.get(key).key);\n        if (view.content === item) toUpdate.delete(key);else {\n          // If the view type changes, delete and recreate the view instead of updating\n          let {\n            reuseType: reuseType\n          } = this._getReuseType(view.layoutInfo, item);\n          if (view.viewType !== reuseType) {\n            toUpdate.delete(key);\n            toAdd.add(key);\n            toRemove.add(key);\n          }\n        }\n      }\n      // We are done if the sets are equal\n      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n        if (this._transaction) this._applyLayoutInfos();\n        return;\n      }\n    }\n    // Track views that should be removed. They are not removed from\n    // the DOM immediately, since we may reuse and need to re-insert\n    // them back into the DOM anyway.\n    let removed = new Set();\n    for (let key1 of toRemove.keys()) {\n      let view1 = this._visibleViews.get(key1);\n      if (view1) {\n        removed.add(view1);\n        this._visibleViews.delete(key1);\n        // If we are in the middle of a transaction, wait until the end\n        // of the animations to remove the views from the DOM. Also means\n        // we can't reuse those views immediately.\n        if (this._transaction) this._transaction.toRemove.set(key1, view1);else this.reuseView(view1);\n      }\n    }\n    for (let key2 of toAdd.keys()) {\n      let layoutInfo = visibleLayoutInfos.get(key2);\n      let view2;\n      // If we're in a transaction, and a layout change happens\n      // during the animations such that a view that was going\n      // to be removed is now not, we don't create a new view\n      // since the old one is still in the DOM, marked as toRemove.\n      if (this._transaction) {\n        // if transaction, get initial layout attributes for the animation\n        if (this._transaction.initialLayoutInfo.has(key2)) layoutInfo = this._transaction.initialLayoutInfo.get(key2);\n        view2 = this._transaction.toRemove.get(key2);\n        if (view2) {\n          this._transaction.toRemove.delete(key2);\n          this._applyLayoutInfo(view2, layoutInfo);\n        }\n      }\n      if (!view2) {\n        // Create or reuse a view for this row\n        view2 = this.getReusableView(layoutInfo);\n        // Add the view to the DOM if needed\n        if (!removed.has(view2)) this._children.add(view2);\n      }\n      this._visibleViews.set(key2, view2);\n      removed.delete(view2);\n    }\n    for (let key3 of toUpdate) {\n      let view3 = currentlyVisible.get(key3);\n      this._renderedContent.delete(key3);\n      this._renderView(view3);\n    }\n    // Remove the remaining rows to delete from the DOM\n    if (!this._transaction) this.removeViews(removed);\n    this._correctItemOrder();\n    this._flushVisibleViews();\n    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n    if (hasLayoutUpdates) requestAnimationFrame(() => {\n      // If we're in a transaction, apply animations to visible views\n      // and \"to be removed\" views, which animate off screen.\n      if (this._transaction) requestAnimationFrame(() => this._applyLayoutInfos());\n    });\n    return hasLayoutUpdates;\n  }\n  afterRender() {\n    if (this.shouldOverscan) this._overscanManager.collectMetrics();\n  }\n  _flushVisibleViews() {\n    // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n    // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n    // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n    // method to build the final tree.\n    let viewsByParentKey = new Map([[null, []]]);\n    for (let view of this._children) {\n      var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;\n      if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);\n      (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);\n      if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);\n    }\n    let buildTree = (parent, views) => views.map(view => {\n      let children = viewsByParentKey.get(view.layoutInfo.key);\n      return this.delegate.renderWrapper(parent, view, children, childViews => buildTree(view, childViews));\n    });\n    let children = buildTree(null, viewsByParentKey.get(null));\n    this.delegate.setVisibleViews(children);\n  }\n  _applyLayoutInfo(view, layoutInfo) {\n    if (view.layoutInfo === layoutInfo) return false;\n    view.layoutInfo = layoutInfo;\n    return true;\n  }\n  _applyLayoutInfos() {\n    let updated = false;\n    // Apply layout infos to visible views\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n      }\n    }\n    // Apply final layout infos for views that will be removed\n    if (this._transaction) {\n      for (let view1 of this._transaction.toRemove.values()) {\n        let cur1 = view1.layoutInfo;\n        if ((cur1 === null || cur1 === void 0 ? void 0 : cur1.key) != null) {\n          let layoutInfo1 = this.layout.getLayoutInfo(cur1.key);\n          if (this._applyLayoutInfo(view1, layoutInfo1)) updated = true;\n        }\n      }\n      for (let view2 of this._transaction.removed.values()) {\n        let cur2 = view2.layoutInfo;\n        let layoutInfo2 = this._transaction.finalLayoutInfo.get(cur2.key) || cur2;\n        layoutInfo2 = this.layout.getFinalLayoutInfo(layoutInfo2.copy());\n        if (this._applyLayoutInfo(view2, layoutInfo2)) updated = true;\n      }\n    }\n    if (updated) this._flushVisibleViews();\n  }\n  _hasLayoutUpdates() {\n    if (!this._transaction) return false;\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (!cur) return true;\n      let layoutInfo = this.layout.getLayoutInfo(cur.key);\n      if (\n      // Uses equals rather than pointEquals so that width/height changes are taken into account\n      !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n    }\n    return false;\n  }\n  reuseView(view) {\n    view.prepareForReuse();\n    this._reusableViews[view.viewType].push(view);\n  }\n  removeViews(toRemove) {\n    for (let view of toRemove) this._children.delete(view);\n  }\n  updateItemSize(key, size) {\n    // TODO: we should be able to invalidate a single index path\n    // @ts-ignore\n    if (!this.layout.updateItemSize) return;\n    // If the scroll position is currently animating, add the update\n    // to a queue to be processed after the animation is complete.\n    if (this._scrollAnimation) {\n      this._sizeUpdateQueue.set(key, size);\n      return;\n    }\n    // @ts-ignore\n    let changed = this.layout.updateItemSize(key, size);\n    if (changed) this.relayout();\n  }\n  startScrolling() {\n    this._isScrolling = true;\n  }\n  endScrolling() {\n    this._isScrolling = false;\n    this._correctItemOrder();\n    this._flushVisibleViews();\n  }\n  _resetAnimatedContentOffset() {\n    // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n    if (!this._animatedContentOffset.isOrigin()) {\n      this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n      this._applyLayoutInfos();\n    }\n  }\n  /**\n  * Scrolls the item with the given key into view, optionally with an animation.\n  * @param key The key of the item to scroll into view.\n  * @param duration The duration of the scroll animation.\n  */\n  scrollToItem(key, options) {\n    // key can be 0, so check if null or undefined\n    if (key == null) return;\n    let layoutInfo = this.layout.getLayoutInfo(key);\n    if (!layoutInfo) return;\n    let {\n      duration = 300,\n      shouldScrollX = true,\n      shouldScrollY = true,\n      offsetX = 0,\n      offsetY = 0\n    } = options;\n    let x = this.visibleRect.x;\n    let y = this.visibleRect.y;\n    let minX = layoutInfo.rect.x - offsetX;\n    let minY = layoutInfo.rect.y - offsetY;\n    let maxX = x + this.visibleRect.width;\n    let maxY = y + this.visibleRect.height;\n    if (shouldScrollX) {\n      if (minX <= x || maxX === 0) x = minX;else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n    }\n    if (shouldScrollY) {\n      if (minY <= y || maxY === 0) y = minY;else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n    }\n    return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y), duration);\n  }\n  /**\n  * Performs an animated scroll to the given offset.\n  * @param offset - The offset to scroll to.\n  * @param duration The duration of the animation.\n  * @returns A promise that resolves when the animation is complete.\n  */\n  scrollTo(offset) {\n    let duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n    // Cancel the current scroll animation\n    if (this._scrollAnimation) {\n      this._scrollAnimation.cancel();\n      this._scrollAnimation = null;\n    }\n    // Set the content offset synchronously if the duration is zero\n    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n      this._setContentOffset(offset);\n      return Promise.resolve();\n    }\n    this.startScrolling();\n    this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), offset => {\n      this._setContentOffset(offset);\n    });\n    this._scrollAnimation.then(() => {\n      this._scrollAnimation = null;\n      // Process view size updates that occurred during the animation.\n      // Only views that are still visible will be actually updated.\n      for (let [key, size] of this._sizeUpdateQueue) this.updateItemSize(key, size);\n      this._sizeUpdateQueue.clear();\n      this.relayout();\n      this._processTransactionQueue();\n      this.endScrolling();\n    });\n    return this._scrollAnimation;\n  }\n  _runTransaction(action, animated) {\n    this._startTransaction();\n    if (this._nextTransaction) this._nextTransaction.actions.push(action);\n    this._endTransaction(animated);\n  }\n  _startTransaction() {\n    if (!this._nextTransaction) this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0)();\n    this._nextTransaction.level++;\n  }\n  _endTransaction(animated) {\n    if (!this._nextTransaction) return false;\n    // Save whether the transaction should be animated.\n    if (animated != null) this._nextTransaction.animated = animated;\n    // If we haven't reached level 0, we are still in a\n    // nested transaction. Wait for the parent to end.\n    if (--this._nextTransaction.level > 0) return false;\n    // Do nothing for empty transactions\n    if (this._nextTransaction.actions.length === 0) {\n      this._nextTransaction = null;\n      return false;\n    }\n    // Default animations to true\n    if (this._nextTransaction.animated == null) this._nextTransaction.animated = true;\n    // Enqueue the transaction\n    this._transactionQueue.push(this._nextTransaction);\n    this._nextTransaction = null;\n    this._processTransactionQueue();\n    return true;\n  }\n  _processTransactionQueue() {\n    // If the current transaction is animating, wait until the end\n    // to process the next transaction.\n    if (this._transaction || this._scrollAnimation) return;\n    let next = this._transactionQueue.shift();\n    if (next) this._performTransaction(next);\n  }\n  _getContentRect() {\n    return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);\n  }\n  _performTransaction(transaction) {\n    this._transaction = transaction;\n    this.relayoutNow({\n      transaction: transaction,\n      animated: transaction.animated,\n      beforeLayout: () => {\n        // Get the initial layout infos for all views before the updates\n        // so we can figure out which views to add and remove.\n        if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n        // Apply the actions that occurred during this transaction\n        for (let action of transaction.actions) action();\n      },\n      afterLayout: () => {\n        // Get the final layout infos after the updates\n        if (transaction.animated) {\n          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n          this._setupTransactionAnimations(transaction);\n        } else this._transaction = null;\n      },\n      afterAnimation: () => {\n        // Remove and reuse views when animations are done\n        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())) {\n          this._children.delete(view);\n          this.reuseView(view);\n        }\n        this._transaction = null;\n        // Ensure DOM order is correct for accessibility after animations are complete\n        this._correctItemOrder();\n        this._flushVisibleViews();\n        this._processTransactionQueue();\n      }\n    });\n  }\n  _setupTransactionAnimations(transaction) {\n    let {\n      initialMap: initialMap,\n      finalMap: finalMap\n    } = transaction;\n    // Store initial and final layout infos for animations\n    for (let [key, layoutInfo] of initialMap) if (finalMap.has(key))\n      // Store the initial layout info for use during animations.\n      transaction.initialLayoutInfo.set(key, layoutInfo);else\n      // This view was removed. Store the layout info for use\n      // in Layout#getFinalLayoutInfo during animations.\n      transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n    // Get initial layout infos for views that were added\n    for (let [key1, layoutInfo1] of finalMap) if (!initialMap.has(key1)) {\n      let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo1.copy());\n      transaction.initialLayoutInfo.set(key1, initialLayoutInfo);\n    }\n    // Figure out which views were removed.\n    for (let [key2, view] of this._visibleViews)\n    // If an item has a width of 0, there is no need to remove it from the _visibleViews.\n    // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n    // added, removed... etc in a loop.\n    if (!finalMap.has(key2) && view.layoutInfo.rect.width > 0) {\n      transaction.removed.set(key2, view);\n      this._visibleViews.delete(key2);\n      // In case something weird happened, where we have a view but no\n      // initial layout info, use the one attached to the view.\n      if (view.layoutInfo) {\n        if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n      }\n    }\n  }\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)();\n    this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();\n    this._persistedKeys = new Set();\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = [];\n    var _options_transitionDuration;\n    // Set options from passed object if given\n    this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n    for (let key of [\"delegate\", \"size\", \"layout\", \"collection\"]) if (options[key]) this[key] = options[key];\n  }\n}\nfunction $fc0b13b484ac1194$export$1505db82fe357e65(opts) {\n  let [visibleViews, setVisibleViews] = (0, $8D3nr$useState)([]);\n  let [contentSize, setContentSize] = (0, $8D3nr$useState)(new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)());\n  let [isAnimating, setAnimating] = (0, $8D3nr$useState)(false);\n  let [isScrolling, setScrolling] = (0, $8D3nr$useState)(false);\n  let virtualizer = (0, $8D3nr$useMemo)(() => new (0, $38b9490c1cca8fc4$export$89be5a243e59c4b2)(), []);\n  virtualizer.delegate = {\n    setVisibleViews: setVisibleViews,\n    setVisibleRect(rect) {\n      virtualizer.visibleRect = rect;\n      opts.onVisibleRectChange(rect);\n    },\n    setContentSize: setContentSize,\n    renderView: opts.renderView,\n    renderWrapper: opts.renderWrapper,\n    beginAnimations: () => setAnimating(true),\n    endAnimations: () => setAnimating(false),\n    getScrollAnchor: opts.getScrollAnchor\n  };\n  virtualizer.layout = opts.layout;\n  virtualizer.collection = opts.collection;\n  virtualizer.transitionDuration = opts.transitionDuration;\n  (0, $8D3nr$useLayoutEffect)(() => {\n    virtualizer.afterRender();\n  });\n  // eslint-disable-next-line arrow-body-style\n  (0, $8D3nr$useEffect)(() => {\n    return () => virtualizer.willUnmount();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  let setVisibleRect = (0, $8D3nr$useCallback)(rect => {\n    virtualizer.visibleRect = rect;\n  }, [virtualizer]);\n  let startScrolling = (0, $8D3nr$useCallback)(() => {\n    virtualizer.startScrolling();\n    setScrolling(true);\n  }, [virtualizer]);\n  let endScrolling = (0, $8D3nr$useCallback)(() => {\n    virtualizer.endScrolling();\n    setScrolling(false);\n  }, [virtualizer]);\n  let state = (0, $8D3nr$useMemo)(() => ({\n    virtualizer: virtualizer,\n    visibleViews: visibleViews,\n    setVisibleRect: setVisibleRect,\n    contentSize: contentSize,\n    isAnimating: isAnimating,\n    isScrolling: isScrolling,\n    startScrolling: startScrolling,\n    endScrolling: endScrolling\n  }), [virtualizer, visibleViews, setVisibleRect, contentSize, isAnimating, isScrolling, startScrolling, endScrolling]);\n  return state;\n}\nexport { $c74cda7d31af1253$export$c84671f46d6a1ca as Layout, $d7fd61009c21d0bb$export$7e0eeb9da702a085 as LayoutInfo, $3041db3296945e6e$export$baf26146a414f24a as Point, $60423f92c7f9ad87$export$c79fc6492f3af13d as Rect, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec as Size, $ad1d98aa8f0c31b4$export$1a5223887c560441 as ReusableView, $fc0b13b484ac1194$export$1505db82fe357e65 as useVirtualizerState };","map":{"version":3,"names":["$c74cda7d31af1253$export$c84671f46d6a1ca","shouldInvalidate","newRect","oldRect","width","height","validate","invalidationContext","getInitialLayoutInfo","layoutInfo","getFinalLayoutInfo","$d7fd61009c21d0bb$export$7e0eeb9da702a085","copy","res","type","key","rect","estimatedSize","opacity","transform","parentKey","isSticky","zIndex","allowOverflow","constructor","$3041db3296945e6e$export$baf26146a414f24a","x","y","equals","point","isOrigin","arguments","length","undefined","$60423f92c7f9ad87$export$c79fc6492f3af13d","maxX","maxY","area","topLeft","topRight","bottomLeft","bottomRight","intersects","containsRect","containsPoint","getCornerInRect","pointEquals","sizeEquals","size","union","other","Math","min","max","intersection","$ee1bfa90a957fb8a$export$cb6da89c6af1a8ec","$ad1d98aa8f0c31b4$var$KEY","$ad1d98aa8f0c31b4$export$1a5223887c560441","prepareForReuse","content","rendered","virtualizer","$3eb131dcf37ad5f8$var$perf","window","performance","$3eb131dcf37ad5f8$var$perfNow","now","webkitNow","msNow","mozNow","$3eb131dcf37ad5f8$var$getTime","bind","Date","getTime","$3eb131dcf37ad5f8$var$fixTs","$3eb131dcf37ad5f8$export$dc0b63720788090c","begin","end","duration","ease","fn","canceled","raf_id","promise","Promise","resolve","start","diffX","diffY","requestAnimationFrame","run","t","delta","proceed","cancel","cancelAnimationFrame","$3eb131dcf37ad5f8$export$77860c106b4a6a2e","$3eb131dcf37ad5f8$export$57636bb43b1ccbb0","sin","PI","$fc36f9a046a9ce79$export$37a26b283fd7740e","a","b","Set","keys","has","add","$fc36f9a046a9ce79$export$acaf96a27438246b","toRemove","toAdd","toUpdate","$fc36f9a046a9ce79$export$cfc14088dfefce5f","_len","iterators","Array","_key","iterator","$fc36f9a046a9ce79$export$6897c284b6f9f4dc","object","$fc36f9a046a9ce79$export$a8d0d0c8d1c5df64","$364191b3decf3697$var$RollingAverage","addSample","sample","count","value","$8D3nr$swchelperssrc_define_propertymjs","$364191b3decf3697$export$4455ee6afb38dcbb","setVisibleRect","time","startTime","averageTime","visibleRect","velocity","collectMetrics","averagePerf","o","abs","overscanY","o1","overscanX","getOverscannedRect","overscanned","round","$8e135e531d8dcb66$export$febc5573c75cefb0","Map","$38b9490c1cca8fc4$export$89be5a243e59c4b2","_setContentSize","_contentSize","delegate","setContentSize","_setContentOffset","offset","_visibleRect","contentSize","_setVisibleRect","forceUpdate","current","shouldOverscan","_overscanManager","layout","_resetAnimatedContentOffset","relayout","offsetChanged","sizeChanged","updateSubviews","collection","_collection","data","_setData","_runTransaction","transitionDuration","reloadData","contentChanged","getItem","persistedKeys","_persistedKeys","isPersistedKey","k","getLayoutInfo","_layout","setLayout","animated","applyLayout","_getReuseType","getType","reuseType","getReusableView","_reusableViews","reusable","view","pop","viewType","_animatedContentOffset","_renderView","reusableView","_renderContent","cached","_renderedContent","get","renderView","set","visibleViews","from","_visibleViews","values","getView","getViewsOfType","filter","v","keyForView","keyAtPoint","layoutInfos","getVisibleLayoutInfos","willUnmount","_relayoutRaf","context","_scrollAnimation","_invalidationContext","Object","assign","relayoutNow","scrollAnchor","_getScrollAnchor","beforeLayout","getContentSize","afterLayout","getVisibleRect","restoredScrollAnchor","_restoreScrollAnchor","contentOffsetX","contentOffsetY","hasLayoutUpdates","transaction","_applyLayoutInfos","_enableTransitions","done","_disableTransitions","afterAnimation","setTimeout","_correctItemOrder","_isScrolling","_transaction","_visibleLayoutInfos","_children","delete","beginAnimations","endAnimations","anchorScrollPosition","getScrollAnchor","corner","key1","anchorScrollPositionAtTop","cornerAnchor","key2","layoutInfo1","corner1","offset1","contentOffset","_context_transaction","finalAnchor","finalMap","adjustment","_getLayoutInfoMap","map","visibleLayoutInfos","currentlyVisible","item","removed","view1","reuseView","view2","initialLayoutInfo","_applyLayoutInfo","key3","view3","removeViews","_flushVisibleViews","_hasLayoutUpdates","afterRender","viewsByParentKey","_view_layoutInfo","_viewsByParentKey_get","_view_layoutInfo1","_view_layoutInfo2","_view_layoutInfo3","push","buildTree","parent","views","children","renderWrapper","childViews","setVisibleViews","updated","cur","cur1","cur2","layoutInfo2","finalLayoutInfo","updateItemSize","_sizeUpdateQueue","changed","startScrolling","endScrolling","scrollToItem","options","shouldScrollX","shouldScrollY","offsetX","offsetY","minX","minY","scrollTo","then","clear","_processTransactionQueue","action","_startTransaction","_nextTransaction","actions","_endTransaction","level","_transactionQueue","next","shift","_performTransaction","_getContentRect","initialMap","_setupTransactionAnimations","WeakMap","_options_transitionDuration","$fc0b13b484ac1194$export$1505db82fe357e65","opts","$8D3nr$useState","isAnimating","setAnimating","isScrolling","setScrolling","$8D3nr$useMemo","onVisibleRectChange","$8D3nr$useLayoutEffect","$8D3nr$useEffect","$8D3nr$useCallback","state"],"sources":["C:\\Users\\Dmitry\\Desktop\\JS\\untitled2\\zaebalo\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\index.ts","C:\\Users\\Dmitry\\Desktop\\JS\\untitled2\\zaebalo\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\Layout.ts","C:\\Users\\Dmitry\\Desktop\\JS\\untitled2\\zaebalo\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\LayoutInfo.ts","C:\\Users\\Dmitry\\Desktop\\JS\\untitled2\\zaebalo\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\Point.ts","C:\\Users\\Dmitry\\Desktop\\JS\\untitled2\\zaebalo\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\Rect.ts","C:\\Users\\Dmitry\\Desktop\\JS\\untitled2\\zaebalo\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\Size.ts","C:\\Users\\Dmitry\\Desktop\\JS\\untitled2\\zaebalo\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\ReusableView.ts","C:\\Users\\Dmitry\\Desktop\\JS\\untitled2\\zaebalo\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\useVirtualizerState.ts","C:\\Users\\Dmitry\\Desktop\\JS\\untitled2\\zaebalo\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\Virtualizer.ts","C:\\Users\\Dmitry\\Desktop\\JS\\untitled2\\zaebalo\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\tween.ts","C:\\Users\\Dmitry\\Desktop\\JS\\untitled2\\zaebalo\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\utils.ts","C:\\Users\\Dmitry\\Desktop\\JS\\untitled2\\zaebalo\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\OverscanManager.ts","C:\\Users\\Dmitry\\Desktop\\JS\\untitled2\\zaebalo\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\Transaction.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {InvalidationContext} from './types';\nexport type {VirtualizerState} from './useVirtualizerState';\nexport type {RectCorner} from './Rect';\n\nexport {Layout} from './Layout';\nexport {LayoutInfo} from './LayoutInfo';\nexport {Point} from './Point';\nexport {Rect} from './Rect';\nexport {Size} from './Size';\nexport {ReusableView} from './ReusableView';\nexport {useVirtualizerState} from './useVirtualizerState';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {InvalidationContext} from './types';\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\n// import {Point} from './Point';\nimport {Rect} from './Rect';\nimport {Size} from './Size';\nimport {Virtualizer} from './Virtualizer';\n// import { DragTarget, DropTarget } from '@react-types/shared';\n\n/**\n * [CollectionView]{@link CollectionView} supports arbitrary layout objects, which compute what views are visible, and how\n * to position and style them. However, layouts do not create the views themselves directly. Instead,\n * layouts produce lightweight {@link LayoutInfo} objects which describe various properties of a view,\n * such as its position and size. The {@link CollectionView} is then responsible for creating the actual\n * views as needed, based on this layout information.\n *\n * Every layout extends from the {@link Layout} abstract base class. Layouts must implement a minimum of the\n * two methods listed below. All other methods can be optionally overridden to implement custom behavior.\n *\n * @see {@link getVisibleLayoutInfos}\n * @see {@link getLayoutInfo}\n */\nexport abstract class Layout<T extends object> {\n  /** The CollectionView the layout is currently attached to. */\n  virtualizer: Virtualizer<T, any, any>;\n\n  /**\n   * Returns whether the layout should invalidate in response to\n   * visible rectangle changes. By default, it only invalidates\n   * when the collection view's size changes. Return true always\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\n   */\n  shouldInvalidate(newRect: Rect, oldRect: Rect): boolean {\n    // By default, invalidate when the size changes\n    return newRect.width !== oldRect.width\n        || newRect.height !== oldRect.height;\n  }\n\n  /**\n   * This method allows the layout to perform any pre-computation\n   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n   * Called by the collection view before {@link getVisibleLayoutInfos}\n   * or {@link getLayoutInfo} are called.\n   */\n  validate(invalidationContext: InvalidationContext<T, any>) {} // eslint-disable-line @typescript-eslint/no-unused-vars\n\n  /**\n   * Returns an array of {@link LayoutInfo} objects which are inside the given rectangle.\n   * Should be implemented by subclasses.\n   * @param rect The rectangle that should contain the returned LayoutInfo objects.\n   */\n  abstract getVisibleLayoutInfos(rect: Rect): LayoutInfo[];\n\n  /**\n   * Returns a {@link LayoutInfo} for the given key.\n   * Should be implemented by subclasses.\n   * @param key The key of the LayoutInfo to retrieve.\n   */\n  abstract getLayoutInfo(key: Key): LayoutInfo;\n\n  /**\n   * Returns size of the content. By default, it returns collectionView's size.\n   */\n  abstract getContentSize(): Size;\n\n  /**\n   * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n   * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n   * @param point The point at which the drag occurred.\n   */\n  // getDragTarget(point: Point): DragTarget | null {\n  //   let target = this.virtualizer.keyAtPoint(point);\n  //   if (!target) {\n  //     return null;\n  //   }\n\n  //   return {\n  //     type: 'item',\n  //     key: target\n  //   };\n  // }\n\n  /**\n   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n   * to reject the drop. The dropped items will be inserted before the resulting target.\n   * @param point The point at which the drop occurred.\n   */\n  // getDropTarget(point: Point): DropTarget | null {\n  //   return null;\n  // }\n\n  /**\n   * Returns the starting attributes for an animated insertion.\n   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n   * The default implementation just returns its input.\n   *\n   * @param layoutInfo The proposed LayoutInfo for this view.\n   */\n  getInitialLayoutInfo(layoutInfo: LayoutInfo): LayoutInfo {\n    return layoutInfo;\n  }\n\n  /**\n   * Returns the ending attributes for an animated removal.\n   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n   * to the one returned by this method. The default implementation returns its input.\n   *\n   * @param layoutInfo The original LayoutInfo for this view.\n   */\n  getFinalLayoutInfo(layoutInfo: LayoutInfo): LayoutInfo {\n    return layoutInfo;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {Rect} from './Rect';\n\n/**\n * Instances of this lightweight class are created by {@link Layout} subclasses\n * to represent each view in the {@link CollectionView}. LayoutInfo objects describe\n * various properties of a view, such as its position and size, and style information.\n * The collection view uses this information when creating actual views to display.\n */\nexport class LayoutInfo {\n  /**\n   * A string representing the view type. Should be `'item'` for item views.\n   * Other types are used by supplementary views.\n   */\n  type: string;\n\n  /**\n   * A unique key for this view. For item views, it should match the content key.\n   */\n  key: Key;\n\n  /**\n   * The key for a parent layout info, if any.\n   */\n  parentKey: Key | null;\n\n  /**\n   * The rectangle describing the size and position of this view.\n   */\n  rect: Rect;\n\n  /**\n   * Whether the size is estimated. `false` by default.\n   */\n  estimatedSize: boolean;\n\n  /**\n   * Whether the layout info sticks to the viewport when scrolling.\n   */\n  isSticky: boolean;\n\n  /**\n   * The view's opacity. 1 by default.\n   */\n  opacity: number;\n\n  /**\n   * A CSS transform string to apply to the view. `null` by default.\n   */\n  transform: string | null;\n\n  /**\n   * The z-index of the view. 0 by default.\n   */\n  zIndex: number;\n\n  /**\n   * Whether the layout info allows its contents to overflow its container.\n   * @default false\n   */\n  allowOverflow: boolean;\n\n  /**\n   * @param type A string representing the view type. Should be `'item'` for item views.\n                            Other types are used by supplementary views.\n   * @param key The unique key for this view.\n   * @param rect The rectangle describing the size and position of this view.\n   */\n  constructor(type: string, key: Key, rect: Rect) {\n    this.type = type;\n    this.key = key;\n    this.parentKey = null;\n    this.rect = rect;\n    this.estimatedSize = false;\n    this.isSticky = false;\n    this.opacity = 1;\n    this.transform = null;\n    this.zIndex = 0;\n    this.allowOverflow = false;\n  }\n\n  /**\n   * Returns a copy of the LayoutInfo.\n   */\n  copy(): LayoutInfo {\n    let res = new LayoutInfo(this.type, this.key, this.rect.copy());\n    res.estimatedSize = this.estimatedSize;\n    res.opacity = this.opacity;\n    res.transform = this.transform;\n    res.parentKey = this.parentKey;\n    res.isSticky = this.isSticky;\n    res.zIndex = this.zIndex;\n    res.allowOverflow = this.allowOverflow;\n    return res;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport class Point {\n  /** The x-coordinate of the point. */\n  x: number;\n\n  /** The y-coordinate of the point. */\n  y: number;\n\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Returns a copy of this point.\n   */\n  copy(): Point {\n    return new Point(this.x, this.y);\n  }\n\n  /**\n   * Checks if two points are equal.\n   */\n  equals(point: Point): boolean {\n    return this.x === point.x && this.y === point.y;\n  }\n\n  /**\n   * Returns true if this point is the origin.\n   */\n  isOrigin(): boolean {\n    return this.x === 0 && this.y === 0;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\nimport {Size} from './Size';\n\nexport type RectCorner = 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';\n\n/**\n * Represents a rectangle.\n */\nexport class Rect {\n  /** The x-coordinate of the rectangle. */\n  x: number;\n\n  /** The y-coordinate of the rectangle. */\n  y: number;\n\n  /** The width of the rectangle. */\n  width: number;\n\n  /** The height of the rectangle. */\n  height: number;\n\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * The maximum x-coordinate in the rectangle.\n   */\n  get maxX(): number {\n    return this.x + this.width;\n  }\n\n  /**\n   * The maximum y-coordinate in the rectangle.\n   */\n  get maxY(): number {\n    return this.y + this.height;\n  }\n\n  /**\n   * The area of the rectangle.\n   */\n  get area(): number {\n    return this.width * this.height;\n  }\n\n  /**\n   * The top left corner of the rectangle.\n   */\n  get topLeft(): Point {\n    return new Point(this.x, this.y);\n  }\n\n  /**\n   * The top right corner of the rectangle.\n   */\n  get topRight(): Point {\n    return new Point(this.maxX, this.y);\n  }\n\n  /**\n   * The bottom left corner of the rectangle.\n   */\n  get bottomLeft(): Point {\n    return new Point(this.x, this.maxY);\n  }\n\n  /**\n   * The bottom right corner of the rectangle.\n   */\n  get bottomRight(): Point {\n    return new Point(this.maxX, this.maxY);\n  }\n\n  /**\n   * Returns whether this rectangle intersects another rectangle.\n   * @param rect - The rectangle to check.\n   */\n  intersects(rect: Rect): boolean {\n    return this.x <= rect.x + rect.width\n        && rect.x <= this.x + this.width\n        && this.y <= rect.y + rect.height\n        && rect.y <= this.y + this.height;\n  }\n\n  /**\n   * Returns whether this rectangle fully contains another rectangle.\n   * @param rect - The rectangle to check.\n   */\n  containsRect(rect: Rect): boolean {\n    return this.x <= rect.x\n        && this.y <= rect.y\n        && this.maxX >= rect.maxX\n        && this.maxY >= rect.maxY;\n  }\n\n  /**\n   * Returns whether the rectangle contains the given point.\n   * @param point - The point to check.\n   */\n  containsPoint(point: Point): boolean {\n    return this.x <= point.x\n        && this.y <= point.y\n        && this.maxX >= point.x\n        && this.maxY >= point.y;\n  }\n\n  /**\n   * Returns the first corner of this rectangle (from top to bottom, left to right)\n   * that is contained in the given rectangle, or null of the rectangles do not intersect.\n   * @param rect - The rectangle to check.\n   */\n  getCornerInRect(rect: Rect): RectCorner | null {\n    for (let key of ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']) {\n      if (rect.containsPoint(this[key])) {\n        return key as RectCorner;\n      }\n    }\n\n    return null;\n  }\n\n  equals(rect: Rect) {\n    return rect.x === this.x\n        && rect.y === this.y\n        && rect.width === this.width\n        && rect.height === this.height;\n  }\n\n  pointEquals(point: Point | Rect) {\n    return this.x === point.x\n        && this.y === point.y;\n  }\n\n  sizeEquals(size: Size | Rect) {\n    return this.width === size.width\n        && this.height === size.height;\n  }\n\n  /**\n   * Returns the union of this Rect and another.\n   */\n  union(other: Rect) {\n    let x = Math.min(this.x, other.x);\n    let y = Math.min(this.y, other.y);\n    let width = Math.max(this.maxX, other.maxX) - x;\n    let height = Math.max(this.maxY, other.maxY) - y;\n    return new Rect(x, y, width, height);\n  }\n\n  /**\n   * Returns the intersection of this Rect with another.\n   * If the rectangles do not intersect, an all zero Rect is returned.\n   */\n  intersection(other: Rect): Rect {\n    if (!this.intersects(other)) {\n      return new Rect(0, 0, 0, 0);\n    }\n\n    let x = Math.max(this.x, other.x);\n    let y = Math.max(this.y, other.y);\n    return new Rect(\n      x,\n      y,\n      Math.min(this.maxX, other.maxX) - x,\n      Math.min(this.maxY, other.maxY) - y\n    );\n  }\n\n  /**\n   * Returns a copy of this rectangle.\n   */\n  copy(): Rect {\n    return new Rect(this.x, this.y, this.width, this.height);\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport class Size {\n  width: number;\n  height: number;\n\n  constructor(width = 0, height = 0) {\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * Returns a copy of this size.\n   */\n  copy(): Size {\n    return new Size(this.width, this.height);\n  }\n\n  /**\n   * Returns whether this size is equal to another one.\n   */\n  equals(other: Size): boolean {\n    return this.width === other.width\n        && this.height === other.height;\n  }\n\n  /**\n   * The total area of the Size.\n   */\n  get area() {\n    return this.width * this.height;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\nimport {Virtualizer} from './Virtualizer';\n\nlet KEY = 0;\n\n/**\n * [CollectionView]{@link CollectionView} creates instances of the [ReusableView]{@link ReusableView} class to\n * represent views currently being displayed. ReusableViews manage a DOM node, handle\n * applying {@link LayoutInfo} objects to the view, and render content\n * as needed. Subclasses must implement the {@link render} method at a\n * minimum. Other methods can be overridden to customize behavior.\n */\nexport class ReusableView<T extends object, V> {\n  /** The CollectionVirtualizer this view is a part of. */\n  virtualizer: Virtualizer<T, V, unknown>;\n\n  /** The LayoutInfo this view is currently representing. */\n  layoutInfo: LayoutInfo | null;\n\n  /** The content currently being displayed by this view, set by the collection view. */\n  content: T;\n\n  rendered: V;\n\n  viewType: string;\n  key: Key;\n\n  constructor(virtualizer: Virtualizer<T, V, unknown>) {\n    this.virtualizer = virtualizer;\n    this.key = ++KEY;\n  }\n\n  /**\n   * Prepares the view for reuse. Called just before the view is removed from the DOM.\n   */\n  prepareForReuse() {\n    this.content = null;\n    this.rendered = null;\n    this.layoutInfo = null;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection} from '@react-types/shared';\nimport {Key, useCallback, useEffect, useMemo, useState} from 'react';\nimport {Layout} from './Layout';\nimport {Rect} from './Rect';\nimport {ReusableView} from './ReusableView';\nimport {Size} from './Size';\nimport {useLayoutEffect} from '@react-aria/utils';\nimport {Virtualizer} from './Virtualizer';\n\ninterface VirtualizerProps<T extends object, V, W> {\n  renderView(type: string, content: T): V,\n  renderWrapper(\n    parent: ReusableView<T, V> | null,\n    reusableView: ReusableView<T, V>,\n    children: ReusableView<T, V>[],\n    renderChildren: (views: ReusableView<T, V>[]) => W[]\n  ): W,\n  layout: Layout<T>,\n  collection: Collection<T>,\n  onVisibleRectChange(rect: Rect): void,\n  getScrollAnchor?(rect: Rect): Key,\n  transitionDuration?: number\n}\n\nexport interface VirtualizerState<T extends object, V, W> {\n  visibleViews: W[],\n  setVisibleRect: (rect: Rect) => void,\n  contentSize: Size,\n  isAnimating: boolean,\n  virtualizer: Virtualizer<T, V, W>,\n  isScrolling: boolean,\n  startScrolling: () => void,\n  endScrolling: () => void\n}\n\nexport function useVirtualizerState<T extends object, V, W>(opts: VirtualizerProps<T, V, W>): VirtualizerState<T, V, W> {\n  let [visibleViews, setVisibleViews] = useState<W[]>([]);\n  let [contentSize, setContentSize] = useState(new Size());\n  let [isAnimating, setAnimating] = useState(false);\n  let [isScrolling, setScrolling] = useState(false);\n  let virtualizer = useMemo(() => new Virtualizer<T, V, W>(), []);\n\n  virtualizer.delegate = {\n    setVisibleViews,\n    setVisibleRect(rect) {\n      virtualizer.visibleRect = rect;\n      opts.onVisibleRectChange(rect);\n    },\n    setContentSize,\n    renderView: opts.renderView,\n    renderWrapper: opts.renderWrapper,\n    beginAnimations: () => setAnimating(true),\n    endAnimations: () => setAnimating(false),\n    getScrollAnchor: opts.getScrollAnchor\n  };\n\n  virtualizer.layout = opts.layout;\n  virtualizer.collection = opts.collection;\n  virtualizer.transitionDuration = opts.transitionDuration;\n\n  useLayoutEffect(() => {\n    virtualizer.afterRender();\n  });\n\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => virtualizer.willUnmount();\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  let setVisibleRect = useCallback((rect) => {\n    virtualizer.visibleRect = rect;\n  }, [virtualizer]);\n  let startScrolling = useCallback(() => {\n    virtualizer.startScrolling();\n    setScrolling(true);\n  }, [virtualizer]);\n  let endScrolling = useCallback(() => {\n    virtualizer.endScrolling();\n    setScrolling(false);\n  }, [virtualizer]);\n\n  let state = useMemo(() => ({\n    virtualizer,\n    visibleViews,\n    setVisibleRect,\n    contentSize,\n    isAnimating,\n    isScrolling,\n    startScrolling,\n    endScrolling\n  }), [\n    virtualizer,\n    visibleViews,\n    setVisibleRect,\n    contentSize,\n    isAnimating,\n    isScrolling,\n    startScrolling,\n    endScrolling\n  ]);\n\n  return state;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CancelablePromise, easeOut, tween} from './tween';\nimport {Collection} from '@react-types/shared';\nimport {concatIterators, difference, isSetEqual} from './utils';\nimport {\n  InvalidationContext,\n  ScrollAnchor,\n  ScrollToItemOptions,\n  VirtualizerDelegate,\n  VirtualizerOptions\n} from './types';\nimport {Key} from 'react';\nimport {Layout} from './Layout';\nimport {LayoutInfo} from './LayoutInfo';\nimport {OverscanManager} from './OverscanManager';\nimport {Point} from './Point';\nimport {Rect} from './Rect';\nimport {ReusableView} from './ReusableView';\nimport {Size} from './Size';\nimport {Transaction} from './Transaction';\n\n/**\n * The CollectionView class renders a scrollable collection of data using customizable layouts,\n * and manages animated updates to the data over time. It supports very large collections by\n * only rendering visible views to the DOM, reusing them as you scroll. Collection views can\n * present any type of view, including non-item views such as section headers and footers.\n * Optionally, the {@link EditableCollectionView} subclass can be used to enable user interaction\n * with the collection, including drag and drop, multiple selection, and keyboard interacton.\n *\n * Collection views get their data from a {@link DataSource} object that you provide. Items are\n * grouped into sections by the data source, and the collection view calls its methods to retrieve\n * the data. When data changes, the data source emits change events, and the collection view\n * updates as appropriate, optionally with an animated transition. There is one built-in data source\n * implementation, {@link ArrayDataSource}, which renders content from a 2d array.\n *\n * Collection views use {@link Layout} objects to compute what views should be visible, and how\n * to position and style them. This means that collection views can have their items arranged in\n * a stack, a grid, a circle, or any other layout you can think of. The layout can be changed\n * dynamically at runtime as well, optionally with an animated transition between the layouts.\n *\n * Layouts produce information on what views should appear in the collection view, but do not create\n * the views themselves directly. It is the responsibility of the {@link CollectionViewDelegate} object\n * to create instances of {@link ReusableView} subclasses which render the items into DOM nodes.\n * The delegate determines what type of view to display for each item, and creates instances of\n * views as needed by the collection view. Those views are then reused by the collection view as\n * the user scrolls through the content.\n */\nexport class Virtualizer<T extends object, V, W> {\n  /**\n   * The collection view delegate. The delegate is used by the collection view\n   * to create and configure views.\n   */\n  delegate: VirtualizerDelegate<T, V, W>;\n\n  /** The duration of animated layout changes, in milliseconds. Default is 500ms. */\n  transitionDuration: number;\n\n  /**\n   * Whether to enable scroll anchoring. This will attempt to restore the scroll position\n   * after layout changes outside the viewport. Default is off.\n   */\n  anchorScrollPosition: boolean;\n\n  /** Whether to anchor the scroll position when at the top of the content. Default is off. */\n  anchorScrollPositionAtTop: boolean;\n\n  /**\n   * Whether to overscan the visible area to pre-render items slightly outside and\n   * improve performance. Default is on.\n   */\n  shouldOverscan: boolean;\n\n  private _collection: Collection<T>;\n  private _layout: Layout<T>;\n  private _contentSize: Size;\n  private _visibleRect: Rect;\n  private _visibleLayoutInfos: Map<Key, LayoutInfo>;\n  private _reusableViews: {[type: string]: ReusableView<T, V>[]};\n  private _visibleViews: Map<Key, ReusableView<T, V>>;\n  private _renderedContent: WeakMap<T, V>;\n  private _children: Set<ReusableView<T, V>>;\n  private _invalidationContext: InvalidationContext<T, V> | null;\n  private _overscanManager: OverscanManager;\n  private _persistedKeys: Set<Key>;\n  private _relayoutRaf: number | null;\n  private _scrollAnimation: CancelablePromise<void> | null;\n  private _isScrolling: boolean;\n  private _sizeUpdateQueue: Map<Key, Size>;\n  private _animatedContentOffset: Point;\n  private _transaction: Transaction<T, V> | null;\n  private _nextTransaction: Transaction<T, V> | null;\n  private _transactionQueue: Transaction<T, V>[];\n\n  constructor(options: VirtualizerOptions<T, V, W> = {}) {\n    this._contentSize = new Size;\n    this._visibleRect = new Rect;\n\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new OverscanManager();\n    this._persistedKeys = new Set();\n\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new Point(0, 0);\n\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = [];\n\n    // Set options from passed object if given\n    this.transitionDuration = options.transitionDuration ?? 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n    for (let key of ['delegate', 'size', 'layout', 'collection']) {\n      if (options[key]) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  _setContentSize(size: Size) {\n    this._contentSize = size;\n    this.delegate.setContentSize(size);\n  }\n\n  _setContentOffset(offset: Point) {\n    let rect = new Rect(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n    this.delegate.setVisibleRect(rect);\n  }\n\n  /**\n   * Get the size of the scrollable content.\n   */\n  get contentSize(): Size {\n    return this._contentSize;\n  }\n\n  /**\n   * Get the collection view's currently visible rectangle.\n   */\n  get visibleRect(): Rect {\n    return this._visibleRect;\n  }\n\n  /**\n   * Set the collection view's currently visible rectangle.\n   */\n  set visibleRect(rect: Rect) {\n    this._setVisibleRect(rect);\n  }\n\n  _setVisibleRect(rect: Rect, forceUpdate = false) {\n    let current = this._visibleRect;\n\n    // Ignore if the rects are equal\n    if (rect.equals(current)) {\n      return;\n    }\n\n    if (this.shouldOverscan) {\n      this._overscanManager.setVisibleRect(rect);\n    }\n\n    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n\n    this._resetAnimatedContentOffset();\n    this._visibleRect = rect;\n\n    if (shouldInvalidate) {\n      this.relayout({\n        offsetChanged: !rect.pointEquals(current),\n        sizeChanged: !rect.sizeEquals(current)\n      });\n    } else {\n      this.updateSubviews(forceUpdate);\n    }\n  }\n\n  get collection(): Collection<T> {\n    return this._collection;\n  }\n\n  set collection(data: Collection<T>) {\n    this._setData(data);\n  }\n\n  private _setData(data: Collection<T>) {\n    if (data === this._collection) {\n      return;\n    }\n\n    if (this._collection) {\n      this._runTransaction(() => {\n        this._collection = data;\n      }, this.transitionDuration > 0);\n    } else {\n      this._collection = data;\n      this.reloadData();\n    }\n  }\n\n  /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */\n  reloadData() {\n    this.relayout({\n      contentChanged: true\n    });\n  }\n\n  /**\n   * Returns the item with the given key.\n   */\n  getItem(key: Key) {\n    return this._collection ? this._collection.getItem(key) : null;\n  }\n\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  get persistedKeys(): Set<Key> {\n    return this._persistedKeys;\n  }\n\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  set persistedKeys(persistedKeys: Set<Key>) {\n    if (!isSetEqual(persistedKeys, this._persistedKeys)) {\n      this._persistedKeys = persistedKeys;\n      this.updateSubviews();\n    }\n  }\n\n  /** Returns whether the given key, or an ancestor, is persisted. */\n  isPersistedKey(key: Key) {\n    // Quick check if the key is directly in the set of persisted keys.\n    if (this._persistedKeys.has(key)) {\n      return true;\n    }\n\n    // If not, check if the key is an ancestor of any of the persisted keys.\n    for (let k of this._persistedKeys) {\n      while (k != null) {\n        let layoutInfo = this.layout.getLayoutInfo(k);\n        if (!layoutInfo) {\n          break;\n        }\n\n        k = layoutInfo.parentKey;\n\n        if (k === key) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get the collection view's layout.\n   */\n  get layout(): Layout<T> {\n    return this._layout;\n  }\n\n  /**\n   * Set the collection view's layout.\n   */\n  set layout(layout: Layout<T>) {\n    this.setLayout(layout);\n  }\n\n  /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */\n  setLayout(layout: Layout<T>, animated = false) {\n    if (layout === this._layout) {\n      return;\n    }\n\n    let applyLayout = () => {\n      if (this._layout) {\n        // @ts-ignore\n        this._layout.virtualizer = null;\n      }\n\n      layout.virtualizer = this;\n      this._layout = layout;\n    };\n\n    if (animated) {\n      // Animated layout transitions are really simple, thanks to our transaction support.\n      // We just set the layout inside a transaction action, which runs after the initial\n      // layout infos for the animation are retrieved from the previous layout. Then, the\n      // final layout infos are retrieved from the new layout, and animations occur.\n      this._runTransaction(applyLayout);\n    } else {\n      applyLayout();\n      this.relayout();\n    }\n  }\n\n  private _getReuseType(layoutInfo: LayoutInfo, content: T | null) {\n    if (layoutInfo.type === 'item' && content) {\n      let type = this.delegate.getType ? this.delegate.getType(content) : 'item';\n      let reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;\n      return {type, reuseType};\n    }\n\n    return {\n      type: layoutInfo.type,\n      reuseType: layoutInfo.type\n    };\n  }\n\n  getReusableView(layoutInfo: LayoutInfo): ReusableView<T, V> {\n    let content = this.getItem(layoutInfo.key);\n    let {reuseType} = this._getReuseType(layoutInfo, content);\n\n    if (!this._reusableViews[reuseType]) {\n      this._reusableViews[reuseType] = [];\n    }\n\n    let reusable = this._reusableViews[reuseType];\n    let view = reusable.length > 0\n      ? reusable.pop()\n      : new ReusableView<T, V>(this);\n\n    view.viewType = reuseType;\n\n    if (!this._animatedContentOffset.isOrigin()) {\n      layoutInfo = layoutInfo.copy();\n      layoutInfo.rect.x += this._animatedContentOffset.x;\n      layoutInfo.rect.y += this._animatedContentOffset.y;\n    }\n\n    view.layoutInfo = layoutInfo;\n\n    this._renderView(view);\n    return view;\n  }\n\n  private _renderView(reusableView: ReusableView<T, V>) {\n    let {type, key} = reusableView.layoutInfo;\n    reusableView.content = this.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n\n  private _renderContent(type: string, content: T) {\n    let cached = this._renderedContent.get(content);\n    if (cached != null) {\n      return cached;\n    }\n\n    let rendered = this.delegate.renderView(type, content);\n    if (content) {\n      this._renderedContent.set(content, rendered);\n    }\n    return rendered;\n  }\n\n  /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */\n  get visibleViews(): ReusableView<T, V>[] {\n    return Array.from(this._visibleViews.values());\n  }\n\n  /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */\n  getView(key: Key): ReusableView<T, V> | null {\n    return this._visibleViews.get(key) || null;\n  }\n\n  /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */\n  getViewsOfType(type: string): ReusableView<T, V>[] {\n    return this.visibleViews.filter(v => v.layoutInfo && v.layoutInfo.type === type);\n  }\n\n  /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */\n  keyForView(view: ReusableView<T, V>): Key | null {\n    if (view && view.layoutInfo) {\n      return view.layoutInfo.key;\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns the key for the item view currently at the given point.\n   */\n  keyAtPoint(point: Point): Key | null {\n    let rect = new Rect(point.x, point.y, 1, 1);\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n\n    // Layout may return multiple layout infos in the case of\n    // persisted keys, so find the first one that actually intersects.\n    for (let layoutInfo of layoutInfos) {\n      if (layoutInfo.rect.intersects(rect)) {\n        return layoutInfo.key;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */\n  willUnmount() {\n    cancelAnimationFrame(this._relayoutRaf);\n  }\n\n  /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */\n  relayout(context: InvalidationContext<T, V> = {}) {\n    // Ignore relayouts while animating the scroll position\n    if (this._scrollAnimation || typeof requestAnimationFrame === 'undefined') {\n      return;\n    }\n\n    // If we already scheduled a relayout, extend the invalidation\n    // context so we coalesce multiple relayouts in the same frame.\n    if (this._invalidationContext) {\n      Object.assign(this._invalidationContext, context);\n      return;\n    }\n\n    this._invalidationContext = context;\n    this._relayoutRaf = requestAnimationFrame(() => {\n      this._relayoutRaf = null;\n      this.relayoutNow();\n    });\n  }\n\n  /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */\n  relayoutNow(context: InvalidationContext<T, V> = this._invalidationContext || {}) {\n    // Cancel the scheduled relayout, since we're doing it now.\n    if (this._relayoutRaf) {\n      cancelAnimationFrame(this._relayoutRaf);\n      this._relayoutRaf = null;\n      // Update the provided context with the current invalidationContext since we are cancelling\n      // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n      context = {...this._invalidationContext, ...context};\n    }\n\n    // Reset the invalidation context\n    this._invalidationContext = null;\n\n    // Do nothing if we don't have a layout or content, or we are\n    // in the middle of an animated scroll transition.\n    if (!this.layout || !this._collection || this._scrollAnimation) {\n      return;\n    }\n\n    let scrollAnchor = this._getScrollAnchor();\n\n    // Trigger the beforeLayout hook, if provided\n    if (typeof context.beforeLayout === 'function') {\n      context.beforeLayout();\n    }\n\n    // Validate the layout\n    this.layout.validate(context);\n    this._setContentSize(this.layout.getContentSize());\n\n    // Trigger the afterLayout hook, if provided\n    if (typeof context.afterLayout === 'function') {\n      context.afterLayout();\n    }\n\n    // Adjust scroll position based on scroll anchor, and constrain.\n    // If the content changed, scroll to the top.\n    let visibleRect = this.getVisibleRect();\n    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n\n    let hasLayoutUpdates = false;\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n      // Save the difference between the current and new content offsets, and apply it to the\n      // individual content items instead. At the end of the animation, we'll reset and set the\n      // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n      // the scroll animation and the content animation.\n      if (context.animated || !this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n        hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n      } else {\n        this._setContentOffset(new Point(contentOffsetX, contentOffsetY));\n      }\n    } else {\n      hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n    }\n\n    // Apply layout infos, unless this is coming from an animated transaction\n    if (!(context.transaction && context.animated)) {\n      this._applyLayoutInfos();\n    }\n\n    // Wait for animations, and apply the afterAnimation hook, if provided\n    if (context.animated && hasLayoutUpdates) {\n      this._enableTransitions();\n\n      let done = () => {\n        this._disableTransitions();\n\n        // Reset scroll position after animations (see above comment).\n        if (!this._animatedContentOffset.isOrigin()) {\n          // Get the content offset to scroll to, taking _animatedContentOffset into account.\n          let {x, y} = this.getVisibleRect();\n          this._resetAnimatedContentOffset();\n          this._setContentOffset(new Point(x, y));\n        }\n\n        if (typeof context.afterAnimation === 'function') {\n          context.afterAnimation();\n        }\n      };\n\n      // Sometimes the animation takes slightly longer than expected.\n      setTimeout(done, this.transitionDuration + 100);\n      return;\n    } else if (typeof context.afterAnimation === 'function') {\n      context.afterAnimation();\n    }\n  }\n\n  /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */\n  private _correctItemOrder() {\n    // Defer until after scrolling and animated transactions are complete\n    if (this._isScrolling || this._transaction) {\n      return;\n    }\n\n    for (let key of this._visibleLayoutInfos.keys()) {\n      let view = this._visibleViews.get(key);\n      this._children.delete(view);\n      this._children.add(view);\n    }\n  }\n\n  private _enableTransitions() {\n    this.delegate.beginAnimations();\n  }\n\n  private _disableTransitions() {\n    this.delegate.endAnimations();\n  }\n\n  private _getScrollAnchor(): ScrollAnchor | null {\n    if (!this.anchorScrollPosition) {\n      return null;\n    }\n\n    let visibleRect = this.getVisibleRect();\n\n    // Ask the delegate to provide a scroll anchor, if possible\n    if (this.delegate.getScrollAnchor) {\n      let key = this.delegate.getScrollAnchor(visibleRect);\n      if (key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n        if (corner) {\n          let key = layoutInfo.key;\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          return {key, layoutInfo, corner, offset};\n        }\n      }\n    }\n\n    // No need to anchor the scroll position if it is at the top\n    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) {\n      return null;\n    }\n\n    // Find a view with a visible corner that has the smallest distance to the top of the collection view\n    let cornerAnchor: ScrollAnchor | null = null;\n\n    for (let [key, view] of this._visibleViews) {\n      let layoutInfo = view.layoutInfo;\n      if (layoutInfo && layoutInfo.rect.area > 0) {\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n        if (corner) {\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          if (!cornerAnchor || (offset < cornerAnchor.offset)) {\n            cornerAnchor = {key, layoutInfo, corner, offset};\n          }\n        }\n      }\n    }\n\n    return cornerAnchor;\n  }\n\n  private _restoreScrollAnchor(scrollAnchor: ScrollAnchor | null, context: InvalidationContext<T, V>) {\n    let contentOffset = this.getVisibleRect();\n\n    if (scrollAnchor) {\n      let finalAnchor = context.transaction?.animated\n        ? context.transaction.finalMap.get(scrollAnchor.key)\n        : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n\n      if (finalAnchor) {\n        let adjustment = (finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y) - scrollAnchor.offset;\n        contentOffset.y += adjustment;\n      }\n    }\n\n    return contentOffset;\n  }\n\n  getVisibleRect(): Rect {\n    let v = this.visibleRect;\n    let x = v.x - this._animatedContentOffset.x;\n    let y = v.y - this._animatedContentOffset.y;\n    return new Rect(x, y, v.width, v.height);\n  }\n\n  getVisibleLayoutInfos() {\n    let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n    return this._visibleLayoutInfos;\n  }\n\n  private _getLayoutInfoMap(rect: Rect, copy = false) {\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map;\n\n    for (let layoutInfo of layoutInfos) {\n      if (copy) {\n        layoutInfo = layoutInfo.copy();\n      }\n\n      map.set(layoutInfo.key, layoutInfo);\n    }\n\n    return map;\n  }\n\n  updateSubviews(forceUpdate = false) {\n    if (!this._collection) {\n      return;\n    }\n\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n    let currentlyVisible = this._visibleViews;\n    let toAdd, toRemove, toUpdate;\n\n    // If this is a force update, remove and re-add all views.\n    // Otherwise, find and update the diff.\n    if (forceUpdate) {\n      toAdd = visibleLayoutInfos;\n      toRemove = currentlyVisible;\n      toUpdate = new Set();\n    } else {\n      ({toAdd, toRemove, toUpdate} = difference(currentlyVisible, visibleLayoutInfos));\n\n      for (let key of toUpdate) {\n        let view = currentlyVisible.get(key);\n        if (!view || !view.layoutInfo) {\n          continue;\n        }\n\n        let item = this.getItem(visibleLayoutInfos.get(key).key);\n        if (view.content === item) {\n          toUpdate.delete(key);\n        } else {\n          // If the view type changes, delete and recreate the view instead of updating\n          let {reuseType} = this._getReuseType(view.layoutInfo, item);\n          if (view.viewType !== reuseType) {\n            toUpdate.delete(key);\n            toAdd.add(key);\n            toRemove.add(key);\n          }\n        }\n      }\n\n      // We are done if the sets are equal\n      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n        if (this._transaction) {\n          this._applyLayoutInfos();\n        }\n\n        return;\n      }\n    }\n\n    // Track views that should be removed. They are not removed from\n    // the DOM immediately, since we may reuse and need to re-insert\n    // them back into the DOM anyway.\n    let removed = new Set<ReusableView<T, V>>();\n\n    for (let key of toRemove.keys()) {\n      let view = this._visibleViews.get(key);\n      if (view) {\n        removed.add(view);\n        this._visibleViews.delete(key);\n\n        // If we are in the middle of a transaction, wait until the end\n        // of the animations to remove the views from the DOM. Also means\n        // we can't reuse those views immediately.\n        if (this._transaction) {\n          this._transaction.toRemove.set(key, view);\n        } else {\n          this.reuseView(view);\n        }\n      }\n    }\n\n    for (let key of toAdd.keys()) {\n      let layoutInfo = visibleLayoutInfos.get(key);\n      let view: ReusableView<T, V> | void;\n\n      // If we're in a transaction, and a layout change happens\n      // during the animations such that a view that was going\n      // to be removed is now not, we don't create a new view\n      // since the old one is still in the DOM, marked as toRemove.\n      if (this._transaction) {\n        // if transaction, get initial layout attributes for the animation\n        if (this._transaction.initialLayoutInfo.has(key)) {\n          layoutInfo = this._transaction.initialLayoutInfo.get(key);\n        }\n\n        view = this._transaction.toRemove.get(key);\n        if (view) {\n          this._transaction.toRemove.delete(key);\n          this._applyLayoutInfo(view, layoutInfo);\n        }\n      }\n\n      if (!view) {\n        // Create or reuse a view for this row\n        view = this.getReusableView(layoutInfo);\n\n        // Add the view to the DOM if needed\n        if (!removed.has(view)) {\n          this._children.add(view);\n        }\n      }\n\n      this._visibleViews.set(key, view);\n      removed.delete(view);\n    }\n\n    for (let key of toUpdate) {\n      let view = currentlyVisible.get(key) as ReusableView<T, V>;\n      this._renderedContent.delete(key);\n      this._renderView(view);\n    }\n\n    // Remove the remaining rows to delete from the DOM\n    if (!this._transaction) {\n      this.removeViews(removed);\n    }\n\n    this._correctItemOrder();\n    this._flushVisibleViews();\n\n    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n    if (hasLayoutUpdates) {\n      requestAnimationFrame(() => {\n        // If we're in a transaction, apply animations to visible views\n        // and \"to be removed\" views, which animate off screen.\n        if (this._transaction) {\n          requestAnimationFrame(() => this._applyLayoutInfos());\n        }\n      });\n    }\n\n    return hasLayoutUpdates;\n  }\n\n  afterRender() {\n    if (this.shouldOverscan) {\n      this._overscanManager.collectMetrics();\n    }\n  }\n\n  private _flushVisibleViews() {\n    // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n    // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n    // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n    // method to build the final tree.\n    let viewsByParentKey = new Map([[null, []]]);\n    for (let view of this._children) {\n      if (view.layoutInfo?.parentKey != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) {\n        viewsByParentKey.set(view.layoutInfo.parentKey, []);\n      }\n\n      viewsByParentKey.get(view.layoutInfo?.parentKey)?.push(view);\n      if (!viewsByParentKey.has(view.layoutInfo?.key)) {\n        viewsByParentKey.set(view.layoutInfo?.key, []);\n      }\n    }\n\n    let buildTree = (parent: ReusableView<T, V>, views: ReusableView<T, V>[]): W[] => views.map(view => {\n      let children = viewsByParentKey.get(view.layoutInfo.key);\n      return this.delegate.renderWrapper(\n        parent,\n        view,\n        children,\n        (childViews) => buildTree(view, childViews)\n      );\n    });\n\n    let children = buildTree(null, viewsByParentKey.get(null));\n    this.delegate.setVisibleViews(children);\n  }\n\n  private _applyLayoutInfo(view: ReusableView<T, V>, layoutInfo: LayoutInfo) {\n    if (view.layoutInfo === layoutInfo) {\n      return false;\n    }\n\n    view.layoutInfo = layoutInfo;\n    return true;\n  }\n\n  private _applyLayoutInfos() {\n    let updated = false;\n\n    // Apply layout infos to visible views\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (cur?.key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    // Apply final layout infos for views that will be removed\n    if (this._transaction) {\n      for (let view of this._transaction.toRemove.values()) {\n        let cur = view.layoutInfo;\n        if (cur?.key != null) {\n          let layoutInfo = this.layout.getLayoutInfo(cur.key);\n          if (this._applyLayoutInfo(view, layoutInfo)) {\n            updated = true;\n          }\n        }\n      }\n\n      for (let view of this._transaction.removed.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      this._flushVisibleViews();\n    }\n  }\n\n  private _hasLayoutUpdates() {\n    if (!this._transaction) {\n      return false;\n    }\n\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (!cur) {\n        return true;\n      }\n\n      let layoutInfo = this.layout.getLayoutInfo(cur.key);\n      if (\n        // Uses equals rather than pointEquals so that width/height changes are taken into account\n        !cur.rect.equals(layoutInfo.rect) ||\n        cur.opacity !== layoutInfo.opacity ||\n        cur.transform !== layoutInfo.transform\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  reuseView(view: ReusableView<T, V>) {\n    view.prepareForReuse();\n    this._reusableViews[view.viewType].push(view);\n  }\n\n  removeViews(toRemove: Set<ReusableView<T, V>>) {\n    for (let view of toRemove) {\n      this._children.delete(view);\n    }\n  }\n\n  updateItemSize(key: Key, size: Size) {\n    // TODO: we should be able to invalidate a single index path\n    // @ts-ignore\n    if (!this.layout.updateItemSize) {\n      return;\n    }\n\n    // If the scroll position is currently animating, add the update\n    // to a queue to be processed after the animation is complete.\n    if (this._scrollAnimation) {\n      this._sizeUpdateQueue.set(key, size);\n      return;\n    }\n\n    // @ts-ignore\n    let changed = this.layout.updateItemSize(key, size);\n    if (changed) {\n      this.relayout();\n    }\n  }\n\n  startScrolling() {\n    this._isScrolling = true;\n  }\n\n  endScrolling() {\n    this._isScrolling = false;\n    this._correctItemOrder();\n    this._flushVisibleViews();\n  }\n\n  private _resetAnimatedContentOffset() {\n    // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n    if (!this._animatedContentOffset.isOrigin()) {\n      this._animatedContentOffset = new Point(0, 0);\n      this._applyLayoutInfos();\n    }\n  }\n\n  /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */\n  scrollToItem(key: Key, options?: ScrollToItemOptions) {\n    // key can be 0, so check if null or undefined\n    if (key == null) {\n      return;\n    }\n\n    let layoutInfo = this.layout.getLayoutInfo(key);\n    if (!layoutInfo) {\n      return;\n    }\n\n    let {\n      duration = 300,\n      shouldScrollX = true,\n      shouldScrollY = true,\n      offsetX = 0,\n      offsetY = 0\n    } = options;\n\n    let x = this.visibleRect.x;\n    let y = this.visibleRect.y;\n    let minX = layoutInfo.rect.x - offsetX;\n    let minY = layoutInfo.rect.y - offsetY;\n    let maxX = x + this.visibleRect.width;\n    let maxY = y + this.visibleRect.height;\n\n    if (shouldScrollX) {\n      if (minX <= x || maxX === 0) {\n        x = minX;\n      } else if (layoutInfo.rect.maxX > maxX) {\n        x += layoutInfo.rect.maxX - maxX;\n      }\n    }\n\n    if (shouldScrollY) {\n      if (minY <= y || maxY === 0) {\n        y = minY;\n      } else if (layoutInfo.rect.maxY > maxY) {\n        y += layoutInfo.rect.maxY - maxY;\n      }\n    }\n\n    return this.scrollTo(new Point(x, y), duration);\n  }\n\n  /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */\n  scrollTo(offset: Point, duration: number = 300): Promise<void> {\n    // Cancel the current scroll animation\n    if (this._scrollAnimation) {\n      this._scrollAnimation.cancel();\n      this._scrollAnimation = null;\n    }\n\n    // Set the content offset synchronously if the duration is zero\n    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n      this._setContentOffset(offset);\n      return Promise.resolve();\n    }\n\n    this.startScrolling();\n\n    this._scrollAnimation = tween(this.visibleRect, offset, duration, easeOut, offset => {this._setContentOffset(offset);});\n    this._scrollAnimation.then(() => {\n      this._scrollAnimation = null;\n\n      // Process view size updates that occurred during the animation.\n      // Only views that are still visible will be actually updated.\n      for (let [key, size] of this._sizeUpdateQueue) {\n        this.updateItemSize(key, size);\n      }\n\n      this._sizeUpdateQueue.clear();\n      this.relayout();\n      this._processTransactionQueue();\n      this.endScrolling();\n    });\n\n    return this._scrollAnimation;\n  }\n\n  private _runTransaction(action: () => void, animated?: boolean) {\n    this._startTransaction();\n    if (this._nextTransaction) {\n      this._nextTransaction.actions.push(action);\n    }\n    this._endTransaction(animated);\n  }\n\n  private _startTransaction() {\n    if (!this._nextTransaction) {\n      this._nextTransaction = new Transaction;\n    }\n\n    this._nextTransaction.level++;\n  }\n\n  private _endTransaction(animated?: boolean) {\n    if (!this._nextTransaction) {\n      return false;\n    }\n\n    // Save whether the transaction should be animated.\n    if (animated != null) {\n      this._nextTransaction.animated = animated;\n    }\n\n    // If we haven't reached level 0, we are still in a\n    // nested transaction. Wait for the parent to end.\n    if (--this._nextTransaction.level > 0) {\n      return false;\n    }\n\n    // Do nothing for empty transactions\n    if (this._nextTransaction.actions.length === 0) {\n      this._nextTransaction = null;\n      return false;\n    }\n\n    // Default animations to true\n    if (this._nextTransaction.animated == null) {\n      this._nextTransaction.animated = true;\n    }\n\n    // Enqueue the transaction\n    this._transactionQueue.push(this._nextTransaction);\n    this._nextTransaction = null;\n\n    this._processTransactionQueue();\n    return true;\n  }\n\n  private _processTransactionQueue() {\n    // If the current transaction is animating, wait until the end\n    // to process the next transaction.\n    if (this._transaction || this._scrollAnimation) {\n      return;\n    }\n\n    let next = this._transactionQueue.shift();\n    if (next) {\n      this._performTransaction(next);\n    }\n  }\n\n  private _getContentRect(): Rect {\n    return new Rect(0, 0, this.contentSize.width, this.contentSize.height);\n  }\n\n  private _performTransaction(transaction: Transaction<T, V>) {\n    this._transaction = transaction;\n\n    this.relayoutNow({\n      transaction: transaction,\n      animated: transaction.animated,\n\n      beforeLayout: () => {\n        // Get the initial layout infos for all views before the updates\n        // so we can figure out which views to add and remove.\n        if (transaction.animated) {\n          transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n        }\n\n        // Apply the actions that occurred during this transaction\n        for (let action of transaction.actions) {\n          action();\n        }\n      },\n\n      afterLayout: () => {\n        // Get the final layout infos after the updates\n        if (transaction.animated) {\n          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n          this._setupTransactionAnimations(transaction);\n        } else {\n          this._transaction = null;\n        }\n      },\n\n      afterAnimation: () => {\n        // Remove and reuse views when animations are done\n        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) {\n          for (let view of concatIterators(transaction.toRemove.values(), transaction.removed.values())) {\n            this._children.delete(view);\n            this.reuseView(view);\n          }\n        }\n\n        this._transaction = null;\n\n        // Ensure DOM order is correct for accessibility after animations are complete\n        this._correctItemOrder();\n        this._flushVisibleViews();\n\n        this._processTransactionQueue();\n      }\n    });\n  }\n\n  private _setupTransactionAnimations(transaction: Transaction<T, V>) {\n    let {initialMap, finalMap} = transaction;\n\n    // Store initial and final layout infos for animations\n    for (let [key, layoutInfo] of initialMap) {\n      if (finalMap.has(key)) {\n        // Store the initial layout info for use during animations.\n        transaction.initialLayoutInfo.set(key, layoutInfo);\n      } else {\n        // This view was removed. Store the layout info for use\n        // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n      }\n    }\n\n    // Get initial layout infos for views that were added\n    for (let [key, layoutInfo] of finalMap) {\n      if (!initialMap.has(key)) {\n        let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n        transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n      }\n    }\n\n    // Figure out which views were removed.\n    for (let [key, view] of this._visibleViews) {\n      // If an item has a width of 0, there is no need to remove it from the _visibleViews.\n      // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n      // added, removed... etc in a loop.\n      if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n        transaction.removed.set(key, view);\n        this._visibleViews.delete(key);\n\n        // In case something weird happened, where we have a view but no\n        // initial layout info, use the one attached to the view.\n        if (view.layoutInfo) {\n          if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) {\n            transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n          }\n        }\n      }\n    }\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\n\n// use high res timer if available\nlet perf = typeof window !== 'undefined' ? window.performance : null;\n// @ts-ignore\nlet perfNow = perf && (perf.now || perf.webkitNow || perf.msNow || perf.mozNow);\nlet getTime = perfNow ? perfNow.bind(perf) : function () {\n  return Date.now ? Date.now() : new Date().getTime();\n};\n\nlet fixTs: boolean;\n\nexport interface CancelablePromise<T> extends Promise<T> {\n  cancel(): void\n}\n\nexport function tween(begin, end, duration, ease, fn): CancelablePromise<void> {\n  let canceled = false;\n  let raf_id: number;\n\n  let promise = new Promise(resolve => {\n    let start = getTime();\n    let diffX = end.x - begin.x;\n    let diffY = end.y - begin.y;\n\n    raf_id = requestAnimationFrame(function run(t) {\n      // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n      // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n      if (fixTs == null) {\n        fixTs = t > 1e12 !== getTime() > 1e12;\n      }\n\n      if (fixTs) {\n        t = getTime();\n      }\n\n      // check if we're done\n      let delta = t - start;\n      if (delta > duration) {\n        fn(end);\n        resolve();\n      } else {\n        // call frame callback after computing eased time and get the next frame\n        let proceed = fn(new Point(\n          begin.x + diffX * ease(delta / duration),\n          begin.y + diffY * ease(delta / duration)\n        ));\n\n        if (proceed !== false && !canceled) {\n          raf_id = requestAnimationFrame(run);\n        }\n      }\n    });\n  }) as CancelablePromise<void>;\n\n  promise.cancel = function () {\n    canceled = true;\n    cancelAnimationFrame(raf_id);\n  };\n\n  return promise;\n}\n\n// easing functions\nexport function linearEasing(t) {\n  return t;\n}\n\nexport function easeOut(t) {\n  return Math.sin(t * Math.PI / 2);\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport function keyDiff<T>(a: Map<T, any>, b: Map<T, any>): Set<T> {\n  let res = new Set<T>();\n\n  for (let key of a.keys()) {\n    if (!b.has(key)) {\n      res.add(key);\n    }\n  }\n\n  return res;\n}\n\n/**\n * Returns the key difference between two maps. Returns a set of\n * keys to add to and remove from a to make it equal to b.\n * @private\n */\nexport function difference<T>(a: Map<T, any>, b: Map<T, any>) {\n  let toRemove = keyDiff(a, b);\n  let toAdd = keyDiff(b, a);\n  let toUpdate = new Set;\n  for (let key of a.keys()) {\n    if (b.has(key)) {\n      toUpdate.add(key);\n    }\n  }\n  return {toRemove, toAdd, toUpdate};\n}\n\n/**\n * Returns an iterator that yields the items in all of the given iterators.\n * @private\n */\nexport function* concatIterators<T>(...iterators: Iterable<T>[]) {\n  for (let iterator of iterators) {\n    yield* iterator;\n  }\n}\n\n/**\n * Inverts the keys and values of an object.\n * @private\n */\nexport function invert(object) {\n  let res = {};\n  for (let key in object) {\n    res[object[key]] = key;\n  }\n\n  return res;\n}\n\n/** Returns whether two sets are equal. */\nexport function isSetEqual<T>(a: Set<T>, b: Set<T>): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (let key of a) {\n    if (!b.has(key)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\nimport {Rect} from './Rect';\n\nclass RollingAverage {\n  private count: number = 0;\n  value: number = 0;\n  \n  addSample(sample: number) {\n    this.count++;\n    this.value += (sample - this.value) / this.count;\n  }\n}\n\nexport class OverscanManager {\n  private startTime = 0;\n  private averagePerf = new RollingAverage();\n  private averageTime = new RollingAverage();\n  private velocity = new Point(5, 5);\n  private overscanX = new RollingAverage();\n  private overscanY = new RollingAverage();\n  private visibleRect = new Rect();\n  \n  setVisibleRect(rect: Rect) {\n    let time = performance.now() - this.startTime;\n    if (time < 500) {\n      this.averageTime.addSample(time);\n\n      if (rect.x !== this.visibleRect.x && time > 0) {\n        this.velocity.x = (rect.x - this.visibleRect.x) / time;\n      }\n\n      if (rect.y !== this.visibleRect.y && time > 0) {\n        this.velocity.y = (rect.y - this.visibleRect.y) / time;\n      }\n    }\n\n    this.startTime = performance.now();\n    this.visibleRect = rect;\n  }\n\n  collectMetrics() {\n    let time = performance.now() - this.startTime;\n    if (time < 500) {\n      this.averagePerf.addSample(time);\n    }\n\n    if (this.visibleRect.height > 0) {\n      let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));  \n      this.overscanY.addSample(o);\n    }\n\n    if (this.visibleRect.width > 0) {\n      let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));  \n      this.overscanX.addSample(o);\n    }\n  }\n\n  getOverscannedRect() {\n    let overscanned = this.visibleRect.copy();\n\n    let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n    if (this.velocity.y > 0) {\n      overscanned.y -= overscanY * 0.2;\n      overscanned.height += overscanY + overscanY * 0.2;\n    } else {\n      overscanned.y -= overscanY;\n      overscanned.height += overscanY + overscanY * 0.2;\n    }\n\n    let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n    if (this.velocity.x > 0) {\n      overscanned.x -= overscanX * 0.2;\n      overscanned.width += overscanX + overscanX * 0.2;\n    } else {\n      overscanned.x -= overscanX;\n      overscanned.width += overscanX + overscanX * 0.2;\n    }\n\n    return overscanned;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\nimport {ReusableView} from './ReusableView';\n\ntype LayoutInfoMap = Map<Key, LayoutInfo>;\nexport class Transaction<T extends object, V> {\n  level = 0;\n  actions: (() => void)[] = [];\n  animated = true;\n  initialMap: LayoutInfoMap = new Map();\n  finalMap: LayoutInfoMap = new Map();\n  initialLayoutInfo: LayoutInfoMap = new Map();\n  finalLayoutInfo: LayoutInfoMap = new Map();\n  removed: Map<Key, ReusableView<T, V>> = new Map();\n  toRemove: Map<Key, ReusableView<T, V>> = new Map();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}